<!--
    --- NOW ---
    TODO: Paint stations in trip viz line animation (once finished, with some sort of arrival info).
    TODO: Allow selecting a random tripset by hitting Space.
    TODO: Allow click-to-hold on the highlighting.
    TODO: Create transition back to the selection screen after the animation is done.

    --- LATER ---
    TODO: Create a trip animations plotting rugplot at the bottom of the screen (and associate info with it!).
    TODO: Advanced rugplot ideas: click-to-jump-to-time, drag-to-select-a-time-period, drag-to-left-edge-to-pin.
-->
<!DOCTYPE html>
<html>
<head>
    <title>A Day in the Life of Citi Bike</title>

    <style type="text/css">
        html { height: 100% }
        body { height: 100%; margin: 0; padding: 0 }
        #map-canvas { height: 100% }
        /* Note that I use a CSS control to change the cursor from a draggy hand to a regular one as well in order to */
        /* keep users from thinking it is interactive at the beginning. */
        /* This is necessary because to keep from distractions the intro animation has zoom and pan disabled. */
        /*.leaflet-container {*/
            /*cursor: default !important;*/
        /*}*/
        /* Station tooltip */
        .station-tip {
            line-height: 1.25;
            padding: 20px;
            background: white;
            color: black;
            border-radius: 5px;
            font-family: Roboto;
            position: absolute;
            left: 50%;
            transform: translate(-50%,0%);
            /*border:1px solid #999;*/
        }
        /* Pure CSS buttons, cf. http://cssdeck.com/labs/purely-css. */
        button.btn {
            display: inline-block;
            color: #666;
            background-color: #eee;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
            cursor: pointer;
        }

        button.btn:hover {
            background-color: #e3e3e3;
            border-color: rgba(0,0,0,0.5);
        }

        button.btn:active {
            background-color: #CCC;
            border-color: rgba(0,0,0,0.9);
        }

        button.btn-disabled {
            display: inline-block;
            color: #aaa;
            border-color: #aaa;
            background: #e3e3e3;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
        }

        button.btn.btn-blue {
            background-color: #699DB6;
            border-color: rgba(0,0,0,0.3);
            text-shadow: 0 1px 0 rgba(0,0,0,0.5);
            color: #FFF;
        }
        button.btn.btn-blue:hover {
            background-color: #4F87A2;
            border-color: rgba(0,0,0,0.5);
        }
        button.btn.btn-blue:active {
            background-color: #3C677B;
            border-color: rgba(0,0,0,0.9);
        }
    </style>


    <link href='https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css'
    	rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
</head>
<body>

    <div id="map-canvas"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="/static/js/d3.v3.js"></script>
    <script src="/static/js/L.D3SvgOverlay.js"></script>
    <script src="https://d3js.org/d3-queue.v3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment.js"></script>
    <script>

        /////////////////////////
        // MAP INITIALIZATION  //
        /////////////////////////
        // The map is via Leaflet, with all drawings and animations implemented on top using L.d3SvgOverlay.

        var map = L.map("map-canvas", {  // Initialize the basemap. Disable animations for the starting anim.
            zoomControl: false,
            scrollWheelZoom: false,
            minZoom: 11
        });
        // Using Leaflet's fitBounds method ensures that the resultant map contains all of the points on all display
        // devices. The precise points were arrived at by the high scientific method of guess-and-check.
        map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]]);
        // More disabling things.
        map.dragging.disable();
        map.keyboard.disable();
        map.doubleClickZoom.disable();
        // Attach the tile layer.
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
            subdomains: 'abcd',
            maxZoom: 16
        }).addTo(map);

        //////////////////////
        // GLOBAL VARIABLES //
        //////////////////////
        // Variables declared inside of the draw callback will be reset every time that the map zoom level is changed.
        // Therefore variables which have to exist outside of the draw state live here.

        // The scale factor global is used while redrawing to keep interactive display elements at a reasonable size at
        // all zoom levels. This is necessary because by default d3SvgOverlay will simply keep the objects at the same
        // size at all zoom levels, which causes massive blobs at high zoom levels and tiny specks at low ones.
        var scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.25);

        // In order to implement the station toggle selection we need to implement a global struct which stores
        // stations selected and the paths that have been drawn associated with them.
        // In the first part of the view, before launching any visualization, this data just contains a list of all of
        // the selected station ids. The actual data is populated once the user hits the Go button, by the bindData()
        // function call. This data is then used by the path generation and timer elements to run the animation.
        var selected_stations = {};

        // The current visualization mode. Used almost everywhere. Possible options are:
        // intro-animation --- the mode the visualization is in at the very beginning, when sampler paths are plotted.
        // intro --- The mode immediately thereafter, with "Follow Stations" and "Follow Bikes" buttons.
        // stations --- The mode when you hit "Follow Stations" in intro, basically the stations selection screen.
        // bikes --- The mode when you hit "Follow Bikes" in intro, basically the stations selection screen.
        // stations-animation --- When the visualization is animating in stations mode.
        // bikes-animation --- When the visualization is animating in bikes mode.
        var viz_mode = "intro-animation";

        // D3-SVG-Overlay callback wrapper.
        var mapOverlay = L.d3SvgOverlay(function(sel,proj) {

            //////////////////////
            // INTRO ANIMATION  //
            //////////////////////
            // For the introduction I wanted to dynamically render a random set of paths (200 of them in the final
            // visualization) before painting the rest of the introductory scene.

            // Paints a single sampler path. Accepts a linearray (an array of points) as input, as well as the position
            // of the line being drawn in placement order. paintPathSampler is the method which actually handles the
            // entire path-sampling introductory animation, and it implements this method over a loop to do that.
            function paintPath(linearray, index) {

                // Define the SVG line reprojection function.
                var line = d3.svg.line()
                        .x(function (d) {
                            return proj.latLngToLayerPoint(d).x
                        })
                        .y(function (d) {
                            return proj.latLngToLayerPoint(d).y
                        });

                // Create a path, bind the line array to its __data__, and call line on it to generate the line-code.
                setTimeout(function () {
                    sel.append('path').datum(linearray)
                            .attr({
                                "class": "sample-line",
                                "d": line,
                                "fill": "transparent",
                                "stroke": "white",
                                "stroke-width": 3,
                                "vector-effect": "non-scaling-stroke"
                            })
                            .transition()
                            .duration(2500)
                            .attr({
                                "stroke": "#99bbd7"
                            })
                }, 25 * i);
            }

            // Paint all of the sampler paths. Wraps paintPath(), above, with consideration removing old paths.
            // The data file itself, `sample_trips.json`, was generated using Python.
            function paintPathSampler() {
                // Remove all of the existing paths first, otherwise we keep old ones!
                sel.selectAll('path').remove();

                d3.json("../../static/post_assets/citibike/sample_trips.json", function (data) {
                    for (i = 0; i < data.length; i++) {
                        paintPath(data[i], i);
                    }
                });
            }

            // Paints all of the stations on the map.
            function paintStations() {
                d3.csv("../../static/post_assets/citibike/june_22_station_metadata.csv", function (error, dataset) {
                    if (error) throw error;

                    setTimeout(function () {
                        sel
                                .append("g")
                                .attr("id", "display-elements")
                                .append("g")
                                .attr("id", "stations")  // groups are for display---cf. launchVisualizationAnimation()
                                .selectAll("circle")
                                .data(dataset)
                                .enter()
                                .append("circle")
                                .attr({
                                    "class": "station station-unselected",
                                    "cx": function (d) {
                                        return proj.latLngToLayerPoint([d.latitude, d.longitude]).x
                                    },
                                    "cy": function (d) {
                                        return proj.latLngToLayerPoint([d.latitude, d.longitude]).y
                                    },
                                    "r": 0,
                                    "stroke": "white",
                                    "stroke-width": 2,
                                    "cursor": "pointer",
                                    "fill": function (d) {
                                        if (d['kind'] == 'active') {
                                            return "#3f75a2";
                                        }
                                        else if (d['kind'] == 'inactive') {
                                            return "#a7a7a7";
                                        }
                                    },
                                    "fill-opacity": 1,
                                    "stroke-opacity": 1,
                                    "z-index": 10
                                })
                                .on('mouseover', function (d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 4,
                                                "r": 10,
                                                "id": "hovered-station"
                                            });
                                    showCard(d);
                                })
                                .on('mouseout', function (d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 2,
                                                "r": 5,
                                                "id": null
                                            });
                                    hideCard();
                                })
                                .on("click", toggleStation)
                                .transition()
                                .duration(500)
                                .attr({
                                    "r": 5
                                })
                    }, 6000);
                });
            }

            // Enables interactions (meant to be used once the animation is done playing).
            function enableInteractions() {
                d3.select("#map-canvas").style("cursor", null);
                map.dragging.enable();
                map.keyboard.enable();
                map.scrollWheelZoom.enable();
            }

            // Disables interactions. Actually not currently used during the intro, used instead during the later
            // actual visualization.
            function disableInteractions() {
                d3.select("#map-canvas").style("cursor", "default");
                map.dragging.disable();
                map.keyboard.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            }


            // This function runs the intro animation.
            function runIntroAnimation() {
                d3.select("#map-canvas").style("cursor", "default");  // change cursor to the default while animating.
                paintPathSampler();  // Animate the sample paths.
                paintStations();  // Animate the stations.
                setTimeout(function () {
                    paintIntroInfo();  // Append the intro text box. This method is from the Info Box code segment.
                }, 6000);
                setTimeout(function () {
                    enableInteractions();
                }, 6000);
            }

            //////////////
            // INFO BOX //
            //////////////
            // Handles the information display on the left-hand side. A different one is created every time the viz
            // mode is switched.

            // Draws the info box. This method is used by the information pane painters (there are three, one for each
            // viz mode: intro, stations, bikes). Since the height and width and whatnot of the display depends on the
            // device, all of the sizing for this box are calculated with respect to extrema on the map.
            function drawInfoBox() {
                // Remove any pre-existing ones, we re-draw every time we return.
                d3.select("#description-block").remove();

                // Create the container.
                d3.select("#map-canvas")
                        .append("div")
                        .attr("id", "description-block")
                        .style({
                            "position": "absolute",
                            "width": "400px",
                            "top": proj.latLngToLayerPoint([40.784642, -73.970002]).y + "px",
                            "left": proj.latLngToLayerPoint([40.704556, -74.026222]).x - 400 - 20 + "px",
                            // ^ (point in the Hudson river) - (width of the box) - (bit of additional padding).
                            "background": "#fff",
                            "border-radius": "5px",
                            "opacity": 0.0,
                            "padding": "10px",
                            "font-family": "Roboto",
                            "text-align": "center",
                            "cursor": "text"
                        })
                        .transition()
                        .duration(1000)
                        .style("opacity", 1.0);

                // Append title.
                d3.select("#description-block")
                        .append("div")
                        .style({
                            "font-size": "24px",
                            "font-weight": "bold"
                        })
                        .text("A Day in the Life of CitiBike");

            }

            // Paints the introductory info box.
            function paintIntroInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["intro"]);
                });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Stations")
                        .on("click", switchToStationsMode);

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Bikes")
                        .on("click", switchToBikesMode);

            }

            // Removes everything from the selection. Used by the Reset GUI element. It's factored out because it's
            // common to both functions.
            // This really ought to be in the station selection block, but for some reason when it's there it breaks my
            // build.
            function clearSelection() {
                d3.selectAll(".station-selected").attr({
                    "stroke": "white",
                    "class": "station"
                });
                selected_stations = {};
                updateSelectionDisplay();
                updateResetAndLaunchButtonStyles();
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // bounces you back to the intro. It's factored out because it's common to both functions.
            function appendMenuGoBack(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Go Back")
                        .on("click", switchToIntroMode);
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // launches the visualization. It's factored out because it's common to both functions.
            function appendMenuLaunch(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "id": "launch-button",
                            "class": function () {
                                var selection_size = Object.keys(selected_stations).length;
                                if (selection_size == 0) {
                                    return "btn-disabled";
                                } else {
                                    return "btn btn-blue";
                                }
                            }
                        })
                        .style("width", "33%")
                        .text("Launch")
                        .on("click", function () {
                            d3.select("#launch-button").attr({"class": "btn-disabled"}).on("click", null);
                            initLoadingScreen();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // removes all of the stations in your current selection. It's factored out because it's common to both
            // functions.
            function appendMenuReset(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": function () {
                                if (Object.keys(selected_stations).length == 0) {
                                    return "btn-disabled";
                                } else {
                                    return "btn"
                                }
                            },
                            "id": "reset-button"
                        })
                        .style("width", "33%")
                        .text("Reset")
                        .on("click", function () {
                            clearSelection();  // in the station selection section.
                            updateSelectionDisplay();  // Necessary in case there are preexisting selections.
                            updateResetAndLaunchButtonStyles();
                        });
            }

            // Paints the stations info box.
            function paintStationsInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["stations"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            // Paints the bikes info box.
            function paintBikesInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["bikes"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            ///////////////////////
            // STATION SELECTION //
            ///////////////////////
            // This code handles when a user clicks on a station, uses the box select, or hits clear selection.

            // Now the function itself. As a UX decision I decided to split *generating* a selection from plotting its
            // data. I did this to allow doing selections on the introduction pane, before the user chooses a
            // visualization mode. For a UX standpoint this is necessary because not having that there would make it
            // awkward for the user to realize that they can click on things later.
            //
            // From a developer standpoint this means that selected_stations can contain just stations without any data
            // bound to them, necessitating that, on triggering a visualization mode, we call a function which checks
            // and binds data to the current selection, if necessary. It also requires a global flag for what mode
            // the visualization is in, intro or stations or bikes. This is `viz_mode` above.
            function toggleStation(d) {
                var sel_station = d3.select(this);
                // Do nothing if the station is inactive.
                if (d['kind'] == 'active') {
                    if (!(d['station id'] in selected_stations)) {
                        // Station is not currently in the selection, so add it.
                        // Notice the semantics: trips are stored as two dict-indexed arrays, one of trips in and one
                        // of trips out.
                        selected_stations[d['station id']] = {'to': null, 'from': null};
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "black", "class": "station station-selected"});
                    }
                    else {
                        // The element is already in the selection, so remove it (this is a toggle after all).
                        delete selected_stations[d['station id']];
                        // Update the display element.
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "white", "class": "station station-unselected"});
                    }
                    // Update the display elements.
                    updateSelectionDisplay();
                    updateResetAndLaunchButtonStyles();
                }
            }

            // The following helper method updates the selection display.
            // It is called by toggleStation() whenever a station is added to the selection or removed from it.
            function updateSelectionDisplay() {
                var selection_size = Object.keys(selected_stations).length;
                if (selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#selection-display").remove();
                }
                else {
                    // If there's just one selection that means we just selected our first station.
                    // So create the display element.
                    // Note: the display element is drawn on the HTML map canvas level, not the SVG level. This is
                    // because it's rather difficult to get an SVG box into the top right corner, but trivial to
                    // do so in HTML.
                    d3.select("#selection-display").remove();
                    d3.select("#map-canvas").append("div")
                            .attr({
                                "id": "selection-display"
                            })
                            .style({
                                "position": "absolute",
                                "top": "20px",
                                "right": "20px",
                                "width": "400px",
                                "background": "transparent",
//                                    "border": "1px solid black",
                                "text-align": "right"
                            })
                            .html(function (d) {
                                // The string is fairly complicated to write, so let's break it up into parts.
                                // First we put down the part that always displays, the selection size.
                                // Since the presence or lack thereof of that pesky "s" depends on the pluralization we
                                // have to deal with that first.
                                var s = "";
                                if (selection_size > 1) {
                                    s = "s";
                                }
                                // Now the basic display string.
                                var display =
                                        "<div style='font-family:Roboto; line-height:1'>" +
                                        "<div style='font-weight: bold; font-size: 24px; '>" +
                                        selection_size + " Station" + s + " Selected</div>";
                                // Ok, if we are on the introductory screen this is all we need.
                                if (viz_mode == "intro") {
                                    return display;
                                }
                                // If not then we have to do more work. For starters, get all of the selected elements.
                                // (when an element is selected it is added to the station-selected class list. This
                                //  is done explicitly for the purposes of this here function!)
                                var all_selected_stations_data = d3.selectAll(".station-selected").data();
                                // We're going to need a trip counter.
                                var total_trips = 0;
                                // Now we'll need to iterate through these and add something which is dependent on the
                                // mode. If we're in stations mode we need "all trips". If we're in bikes mode we need
                                // "outbound trips" plus "inbound trips".
                                var i = 0;
                                if (viz_mode == "stations") {
                                    for (i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['all trips'];
                                    }
                                }
                                else if (viz_mode == "bikes") {
                                    for (i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['outbound trips'];
                                        total_trips += +all_selected_stations_data[i]['inbound trips'];
                                    }
                                }
                                // Write this data to the string.
                                display += "<br/>" + total_trips + " trips will be plotted." + "</div>";
                                return display;
                            });
                }

            }

            // Sets or unsets updateButton clickiness based on whether or not there are stations are in the current
            // selection.
            function updateResetAndLaunchButtonStyles() {
                var selection_size = Object.keys(selected_stations).length;
                if (selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#reset-button").attr({"class": "btn-disabled"}).on("click", null);
                    d3.select("#launch-button").attr({"class": "btn-disabled"}).on("click", null);
                }
                else {
                    d3.select("#reset-button").attr({"class": "btn"}).on("click", function(d) {
                            clearSelection();  // in the station selection section.
                            updateSelectionDisplay();  // Necessary in case there are preexisting selections.
                            updateResetAndLaunchButtonStyles();
                    });
                    d3.select("#launch-button").attr({"class": "btn btn-blue"}).on("click", function(d) {
                            d3.select("#launch-button").attr({"class": "btn-disabled"}).on("click", null);
                            initLoadingScreen();
                    });
                }
            }

            ///////////
            // CARDS //
            ///////////
            // Cards are little infoboxes which appear in UI either on the bottom of the page or at the top of the page
            // (bottom outside a visualization animation, in order to avoid colliding with the side-text; top during a
            // visualization animation, in order to avoid colliding with the rugplot).
            //
            // The HTML contents of the cards are generated by functions which have been decoupled from the driver
            // function which creates or deletes the card itself from the screen. This is because in general, I
            // distinguish between three card types:
            //
            // 1. The card that displays when the station is being hovered over in a non-animated mode. The content
            //    displayed in this case is contingent on which of the non-animated modes the reader is in: intro mode
            //    (viz_mode == "intro"), station selection mode (== stations), or bike selection mode (== bikes). These
            //    cards display general information about the amount of trips that will be plotted by the animation.
            // 2. The card that displays when the station is being hovered over in stations animated mode
            //    (viz_mode == "stations-animated"). This card is only available for stations which were starting or
            //    ending points for a trip, and they just display the name and the number of trips that have arrived
            //    there so far for that station.
            // 3. The card that displays when the station is being hovered over in bikes animated mode
            //    (viz_mode == "bikes-animated"). This card is only available for stations which were starting or
            //    ending points for a bike-day, and they just display the name and the number of trips that have ended
            //    or started there so far for that station.

            // Helper function which, given a station selection as the variable d, returns a label that is appropriate
            // for displaying in the card for this station when the visualization is outside of any animation mode.
            // Implements (1) above.
            function getNonAnimationLabel(d) {
                var underline = null;
                if (d['kind'] == 'inactive') {
                    underline = "Out of Service" + "</span></div>";
                }
                else {
                    if (viz_mode == 'intro') {
                        var bikes_out_in = +d['bikes outbound'] + +d['bikes inbound'];
                        // Pluralize!
                        var bikes_out_s = "s";
                        var trips_s = "s";
                        if (+d['all trips'] == 1) {
                            trips_s = "";
                        }
                        if (bikes_out_in == 1) {
                            bikes_out_s = "";
                        }

                        underline = d['all trips'] +
                                " trip" + trips_s + " to or from here.<br/>" +
                                bikes_out_in + " bike" + bikes_out_s + " began or ended the day here." +
                                "</span></div>";
                    }
                    else if ((viz_mode == 'stations') || (viz_mode == 'stations-animation')) {
                        underline = d['incoming trips'] +
                                " trips to this station.<br/>"
                                + d['outgoing trips']
                                + " trips from this station.<br/>"
//                                    + d['all trips'] + " trips total."
                                + "</span></div>";
                    }
                    else if ((viz_mode == 'bikes') || (viz_mode == 'bikes-animation')) {
                        // Pluralize!
                        var out_s = "s";
                        if (+d['bikes outbound'] == 1) {
                            out_s = "";
                        }
                        underline = d['bikes outbound'] +
                                " bike" + out_s + " started the day here.<br/> " +
                                d['bikes inbound'] + " ended it here." +
                                "</span></div>";
                    }
                }
                return "<div style='text-align:center'>" +
                        "<span style='font-weight:bold; font-size:24px;'>" +
                        d['station name'] +
                        "</span><br/><span style='font-size:16px;'>" + underline;
            }

            // HTML function which gets the HTML content of the card which is appropriate for the given selection (`d`)
            // in the case of that station being one of the stations visible in stations mode due to it being a source
            // or sink of trips.
            //
            // Uses the data which is provided for this purpose as the dict variable `station_counters`, defined in the
            // trip setting section far below this method definition.
            function getStationsAnimationLabel(d) {
                return "12";
            }
            // TODO: Implement.

            // HTML function which gets the HTML content of the card which is appropriate for the given selection (`d`)
            // in the case of that station being one of the stations in bikes mode due to it being a source
            // or sink of trips.
            //
            // Uses the data which is provided for this purpose as the dict variable `station_counters`, defined in the
            // trip setting section far below this method definition.
            function getBikesAnimationLabel(d) {
                return "24";
            }
            // TODO: Implement.

            // Displays the appropriate tooltip for the selected station. Master method for this set of functions.
            // The `d` parameter is merely the station selection in question.
            function showCard(d) {
                var sel_station = d3.select("#hovered-station");
                var card = d3.select("#map-canvas")
                        .append("div")
                        .attr({"class": "station-tip"})
                        .html(function () {
                            if ((viz_mode == "intro") || (viz_mode == "bikes") || (viz_mode == "stations")) {
                                return getNonAnimationLabel(d);
                            } else if (viz_mode == "stations-animation") {
                                return getStationsAnimationLabel(d);  // TODO: Implement.
                            } else if (viz_mode == "bikes-animation") {
                                return getBikesAnimationLabel(d);  // TODO: Implement.
                            }
                        });
                // the position of the tooltip---top or bottom---depends on what mode we are in.
                if ((viz_mode == "intro") || (viz_mode == "bikes") || (viz_mode == "stations")) {
                    card.style("bottom", "50px");
                } else {
                    card.style("top", "80px");
                }
            }

            // Removes the tooltip.
            function hideCard() { d3.select(".station-tip").remove(); }

            ////////////////////
            // MODAL SWITCHES //
            ////////////////////
            // Design:
            // When you click the modal buttons, this code takes you to that visualization mode. What happens then is
            // TBD.
            //

            // Once you have gotten as far as selecting a visualization type the sampler paths go bye-bye.
            function fadeOutSamplerPaths() {
                var sample_lines = d3.selectAll(".sample-line");
                sample_lines
                        .transition()
                        .duration(2000)
                        .style({"opacity": 0})
                        .remove();
            }

            function switchToBikesMode() {
                viz_mode = "bikes";
                fadeOutSamplerPaths();
                paintBikesInfo();
                applyBikesModeColorMap();
                updateSelectionDisplay();
            }

            function switchToStationsMode() {
                viz_mode = "stations";
                fadeOutSamplerPaths();
                paintStationsInfo();
                applyStationsModeColorMap();
                updateSelectionDisplay();
            }

            function switchToIntroMode() {
                viz_mode = "intro";
                paintIntroInfo();
                applyIntroColorMap();
                updateSelectionDisplay();
            }

            //////////////////
            // COLORIZATION //
            //////////////////
            // Design:
            // These functions define the colormap for each of the different viz types.
            //

            function applyBikesModeColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                } else if (d['delta bikes'] < 0) {
                                    return "#d8b365";
                                } else if (d['delta bikes'] >= 0) {
                                    return "#3f75a2";
                                }
                            }
                        });
            }

            function applyStationsModeColorMap() {
//                var stations_color_scale = d3.scale.linear().domain([0, 1500]).range(["#a7c4dd", "#152635"]);
                var all_data = d3.selectAll(".station").data().map(function (d) {
                    return d['all trips']
                });
                var stations_color_scale = d3.scale.quantile().domain(all_data).range(['lightsteelblue',
                    'steelblue', '#2b4f6d']);

                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                } else {
                                    return stations_color_scale(d['all trips']);
                                }
                            }
                        });
            }

            function applyIntroColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                } else {
                                    return "#3f75a2";
                                }
                            }
                        });
            }

            //////////////////
            // RE-RENDERING //
            //////////////////
            // Design:
            // These methods handle tweaking stations and jittering the hover tooltip when the map is zoomed, so that
            // everything stays in the correct place and has the correct size.

            function rerenderStations() {
                d3.selectAll(".station")
                        .attr({
                            "r": 5 * scale_factor,
                            "stroke-width": 2 * scale_factor
                        })
                        .on('mouseover', function (d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 4 * scale_factor,
                                        "r": 10 * scale_factor,
                                        "id": "hovered-station"
                                    });
                            showCard(d);
                        })
                        .on('mouseout', function (d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 2 * scale_factor,
                                        "r": 5 * scale_factor,
                                        "id": null
                                    });
                            hideCard();
                        });
            }

            ////////////////////
            // LOADING SCREEN //
            ////////////////////
            // Design:
            // Data is actually bound the selection at the moment when the Launch button is hit.
            // A loading screen keeps the user busy while they wait.
            // This section implements that loading screen.

            // Nicely fades out the data elements present in the selection which are not present in the animation.
            function unpaintNonAnimatedDisplayElements() {
                d3.select("#description-block").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#selection-display").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // When the visualization is done, replace the data elements back onto the screen.
            function repaintNonAnimatedDisplayElements() {
                return null;
                // TODO: Implement.
            }

            // Emits the non-data elements of the loading screen: the background panel, "Loading..." text, and the cute
            // loading animation.
            function paintLoadingElements() {
                // Fade in the background panel.
                var panel = sel.append("rect")
                        .attr({
                            "fill": "black",
                            "width": "100%",
                            "height": "100%",
                            "fill-opacity": 0.0,
                            "id": "background-panel"
                        })
                        .transition()
                        .duration(1000)
                        .attr({"fill-opacity": 0.5});

                var loader = d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50%",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto"
                        })
                        .attr("id", "loader");

                loader.append("img")
                        .attr({"src": "http://127.0.0.1:5000/static/post_assets/citibike/loading-ring.svg"});

                loader.append("div")
                        .style({
                            "margin": "auto",
                            "font-weight": "bold",
                            "font-size": "30px",
                            "color": "white",
                            "font-family": "Roboto"
                        })
                        .text("Loading...");
            }

            // Kills the loading screen. Called once the API data is properly bound, as a part of exitLoadingScreen.
            function unpaintLoadingScreen() {
                d3.select("#loader").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#background-panel").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // The following funcs make the API calls which bind the data elements needed to run the visualization.
            //
            // We populate two data elements here. The first element that we populate is selected_stations, a data
            // struct containing trip information organized thusly:
            //
            // {
            //      <stationid>:
            //          {
            //           'from': [{'geometry': <trip geometry array>, 'properties': <trip properties dict>}, {...}, ...]
            //           'to': [{...}, ...]
            //          },
            //      <...>: {...},
            //      ...
            // }
            //
            // This element contains the information that is used for drawing things. The visualization happens around
            // "ticks" representing minutes, however, and it would be prohibitively expensive to have to check the
            // entire struct for trips happening on the current tick. Instead, I create a lookup table that looks like
            // this:
            //
            // [{'starttime': <moment>,
            //   'stationid': <stationid>,
            //   'type': <from/to>,
            //   'position': <array index>},
            //   {...}]
            //
            // This is `trips_timetable`, below.
            var trips_timetable = [];
            // We'll need to store the current time.
            // The current time is stored here.
            var current_time = moment.utc(0);  // moment.js object
            // It's also useful for us to track what the next time is.
            var next_time = null;  // moment.js object
            // What the current index of interest is.
            var current_index = 0;
            // The time we end everything on.
            var end_time = null;  // moment.js object
            // The interval id assigned to the setInterval instance which runs our timer.
            var interval_id = null;
            // How long a tick lasts (in ms).
            var tick_time = 250;

            // Helper function which assigns data to the selected_stations global variable, with a null callback meant
            // for implementation, via d3.queue, in a waiting method. This is necessary because d3.json is asynchronous,
            // but we want to force it into a blocking thread.
            //
            // Parameter "station_id" is the station id in question. "api_path" is the path of the API URI that is to be
            // used. These two parameters together build the string used for the API call.
            function getStationData(station_id, api_path, callback) {
                d3.json("http://127.0.0.1:5000/citibike-api/" + api_path + "/id/" + station_id, function (data) {
                    if ((api_path == "bike-inbounds") || (api_path == "incoming-trips")) {  // yes, a little redundant
                        selected_stations[station_id]['to'] = data;
                    } else {
                        selected_stations[station_id]['from'] = data;
                    }
                    callback(null);
                });
            }

            // This function binds the data at runtime. It uses getStationData(), defined above.
            // The "callback" parameter should be filled with the function which will run once the data bind is done---
            // in our case this is unpaintLoadingScreen!
            function bindData(call_this_once_done) {
                // The calls to the API are handled by an asynchronous d3 queue, which waits for selected_stations to
                // finish populating before proceeding before continuing. The code below is what executes that.
                var api_paths = null;
                if (viz_mode == "bikes") {
                    api_paths = ["bike-inbounds", "bike-outbounds"]
                } else {
                    api_paths = ["incoming-trips", "outgoing-trips"]
                }
                var station_ids = [];
                for (let station_id in selected_stations) {  // let is needed here due to closure stuff
                    if (selected_stations.hasOwnProperty(station_id)) {
                        station_ids.push(station_id);
                    }
                }
                var q = d3.queue();
                for(var i = 0; i < Object(station_ids).length; i++) {
                    q.defer(getStationData, station_ids[i], api_paths[0]);
                    q.defer(getStationData, station_ids[i], api_paths[1]);
                }
                q.awaitAll(function(error) {
                    if (error) throw error;
                    // We wait for all of the data populate. Once that's done, we proceed with creating the timetable.
                    var key = null;
                    console.log(selected_stations);
                    for(key in selected_stations) {  // let is not necessary here because we are in a blocking thread
                        if (selected_stations.hasOwnProperty(key)) {
                            var types = ['from', 'to'];
                            for(var j = 0; j < types.length; j++) {
                                var type = types[j];
                                for(var k = 0; k < selected_stations[key][type].length; k++) {
                                    var trip = selected_stations[key][type][k];
                                    var starttime = moment(trip['properties']['starttime'], '6/22/2016 hh:mm:ss');
                                    trips_timetable.push({
                                        'starttime': starttime,
                                        'stationid': key,
                                        'type': type,
                                        'position': k
                                    });
                                }
                            }
                        }
                    }
                    // Now we need to sort the timetable. This is done using built-in moment object comparison.
                    trips_timetable = trips_timetable.sort(function(a, b) { return a['starttime'] > b['starttime']; });
                    // Set the next_time parameter.
                    next_time = trips_timetable[0]['starttime'];
                    // Start the viz off at the first trip of the day. (deep copy)
                    current_time = next_time.clone();
                    // Where we end the visualization.
                    var end_ref = trips_timetable[trips_timetable.length - 1];
                    var end_trip = selected_stations[end_ref['stationid']][end_ref['type']][end_ref['position']];
                    end_time = moment(end_trip['properties']['stoptime']);
                    console.log(trips_timetable);
                    // Initialize the loop and continue!
                    call_this_once_done();
                });
            }

            // Removes non-selected stations from the map.
            function unpaintUnselectedStations() {
                d3.selectAll(".station-unselected")
                        .transition()
                        .duration(2500)
                        .attr({
                            "fill-opacity": 0,
                            "stroke-opacity": 0
                        });//.remove();
                // Disable deselection of selected stations.
                d3.selectAll(".station").on("click", null);
                // TODO: Investigate why this doesn't work properly.
                d3.selectAll(".station-unselected").style("cursor", null);
                d3.selectAll(".station-unselected").on('mouseover', null);
                d3.selectAll(".station-unselected").on('mouseout', null);
                // Disable hover for the now-hidden stations.
            }

            // Transitions the map view back to the default one.
            function resetView() {
                map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]],
                        options={'animate':true});
            }

            // Runners for all these things.

            // Continues the transition by removing the loading screen, dropping non-selected stations, zooming out to
            // a planar view, and fiddling with interactivity. Then hands things off to the visualization runner!
            function exitLoadingScreen() {
                var q = d3.queue();
                function transit(callback) {
                    unpaintLoadingScreen();
                    unpaintUnselectedStations();
                    // Paint the timer ahead of launch.
                    paintTimer();
                    // Wait a little bit to allow painters to finish and the user to realize that this is happening.
                    setTimeout(function() {
                        callback(null);
                    }, 1000);
                }
                q.defer(transit);
                q.await(function() {
                    launchVisualizationAnimation();
                });
            }

            // First part of the transition. exitLoadingScreen finishes the job after data has loaded.
            function initLoadingScreen() {
                disableInteractions();
                resetView();
                unpaintNonAnimatedDisplayElements();
                paintLoadingElements();
                bindData(exitLoadingScreen);
            }

            /////////////////////
            // TRIP ANIMATIONS //
            /////////////////////
            // These methods handle the core trip animation elements: timekeeping, the timer, and the actual trip-line
            // plotting.

            // Creates the on-screen timer element.
            function paintTimer() {
                d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50px",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto",
                            "opacity": 0,
                            "cursor": "text"
                        })
                        .attr("id", "timer")
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1
                        });

                d3.select("#timer").append("div")
                        .style({
                            "font-size": "40px",
                            "font-weight": "bold"
                        })
                        .attr("id", "timer-text")
                        .text(current_time.format('h:mm A'));
            }

            // Removes the trip animation timer element.
            function unpaintTimer() {
                d3.select("#timer").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Moves the timer forward one tick (one minute) and changes everything that happens as a result.
            function incrementTimer() {
                current_time = current_time.add(1, 'minutes');
                // If we aren't at the end, do stuff.
                if (current_time.format('h:mm A') != end_time.format('h:mm A')) {
                    d3.select("#timer-text").text(current_time.format('h:mm A'));  // Update display.
                    fireLinePainters();
                }
                // If we are at the end, finish and clean up.
                else {
                    fireLinePainters();
                    exitVisualizationAnimation();
                }
            }

            // Handles the line drawing stuff.
            function fireLinePainters() {
                // We only paint things if next_time indicates that a trip happened this minute.
                if (current_time.format('h:mm A') == next_time.format('h:mm A')) {
                    while(trips_timetable[current_index]['starttime'].format('h:mm A') == next_time.format('h:mm A')) {
                        var curr = trips_timetable[current_index];
                        var tripdata = selected_stations[curr['stationid']][curr['type']][curr['position']];
                        var trip_type = curr['type'];
                        fireLinePainter(tripdata, trip_type);
                        current_index++;
                    }
                    next_time = trips_timetable[current_index]['starttime'];
                }
            }

            // This helper method for `fireLinePainters()`, above, handles actually painting one line.
            // The tripdata parameter is the trip's entry in selected_stations---this contains all of the data about
            // the trip itself. The trip_type parameter is the trip type: to/from.
            function fireLinePainter(tripdata, trip_type) {

                // The coordinates that are to be drawn.
                var linedata = tripdata['geometry']['coordinates'];
                // The duration of the line animation, matching the duration of the ride.
                var duration = moment.duration(
                    moment(tripdata['properties']['stoptime']).diff(moment(tripdata['properties']['starttime']))
                ).asMinutes() * tick_time;
                var c = null;  // the color the trip is initially plotted in.
                var fc = null;  // the color the trip eventually fades to.

                // The colors to use for the animation. We pick a bright draw line which then fades to a lighter color
                // for a period of time after the draw is done, by default. However, this behavior changes if we are in
                // a highlighting mode. In that case, the unhighlighted draw color gets muted, while the highlighted
                // draw color doesn't fade.
                if ((trip_type == 'to') && (!highlight_to) && (!highlight_from)) { c = "steelblue"; fc = "#99bbd7" }
                else if ((trip_type == 'to') && (!highlight_to) && (highlight_from)) { c = "#99bbd7"; fc = "#99bbd7"; }
                else if ((trip_type == 'to') && (highlight_to)) { c = "steelblue"; fc = "steelblue"; }
                else if ((trip_type == 'from') && (!highlight_from) && (!highlight_to)) { c = "#b47846"; fc = "#d7b599" }
                else if ((trip_type == 'from') && (!highlight_from) && (highlight_to)) { c = "#d7b599"; fc = "#d7b599"; }
                else if ((trip_type == 'from') && (highlight_from)) { c = "#b47846"; fc = "#b47846"; }

                // The linearization algorithm...
                var line = d3.svg.line()
//                        .interpolate("cardinal")
                        .x(function(d) { return proj.latLngToLayerPoint(d).x; })
                        .y(function(d) { return proj.latLngToLayerPoint(d).y; });
                // And the class of the trip, for use by the highlighting selector.
                var composite_class = "trip-line trip-line-" + trip_type;

                // display-elements is the id given to the <g> tag which holds (1) all of the station circle elements
                // that are initialized when the introductory animation is finished and (2) all of the paths that we
                // are now appending underneath them.
                //
                // In an SVG things are plotted in "painter" mode: the order of the elements is the order in which they
                // appear in the document body. This is the default behavior when we use "append"; we don't want that.
                // Hence we use this group, selected by id, and the d3 "insert" method (with the :first-child CSS
                // selector) to prepend the path instead.
                // cf. http://stackoverflow.com/questions/26234636/d3-js-prepend-similar-to-jquery-prepend

                var path = d3.select("#trips").append("path");
                path
                        .attr({
                            "class": composite_class,
                            "d": line(linedata),
                            "stroke-width": "2",
                            "fill": "none",
                            "stroke": c
//                            "vector-effect": "non-scaling-stroke"
                        });
                var totalLength = path.node().getTotalLength();
                // Plot through the trip time.
                path
                        .attr("stroke-dasharray", totalLength + " " + totalLength)
                        .attr("stroke-dashoffset", totalLength)
                        .transition()
                        .duration(duration)
                        .attr("stroke-dashoffset", 0)
                        .each("start", pathStartEvent) // fires station trigger code which plots or updates the
                        .each("end", pathEndEvent);    // plot of a related station, if appropriate.
                // TODO: Implement trigger.
                // Bind the trip data to the path, for use later.
                var data_to_bind = tripdata['properties'];
                data_to_bind['type'] = trip_type;  // used by the highlighting colorizers.
                data_to_bind['fading-anim'] = false;  // used by the highlighter to cancel the fading transition.
                path.datum(data_to_bind);
//                path.data()['type'] = trip_type;
                // Populate the highlighter events.
                if (viz_mode == "stations-animation") {
                    path.on("mouseover", highlightSinglePath);
                    path.on("mouseout", unhighlightSinglePath);
                }
                else if (viz_mode == "bikes-animation") {
                    path.on("mouseover", highlightPaths);
                    path.on("mouseout", unhighlightPaths);
                }
                // Change the cursor to highlight interactivity.
                path.style("cursor", "pointer");
                // Fade color after plotting is done, *if* not in any highlighting mode.
                if ((!highlight_to) && (!highlight_from)) {
                    path
                            .transition()
                            .delay(duration)
                            .duration(30 * tick_time)
                            .attr("stroke", fc)
                            // The lines below are necessary flags for the highlighter to work as expected. See the
                            // notes in that section on why they are needed.
                            .each('start', function(d) { path.datum()['fading-anim'] = true; })
                            .each('end', function(d) { path.datum()['fading-anim'] = false; })
                }
            }

            function launchVisualizationAnimation() {
                // Set the global viz_mode flag appropriately  (used by e.g. the tooltip display).
                viz_mode = viz_mode + "-animation";
                // Enable interactions again, and set the visualization flag to true.
                enableInteractions();
                // Create a new group for the lines.
                // This group is placed before the stations in the document object model so that the lines appear
                // *below* the stations.
                //
                // display-elements is the id given to the <g> tag which holds (1) all of the station circle elements
                // that are initialized when the introductory animation is finished and (2) all of the paths that we
                // are now appending underneath them. These are sorted, respectively, into the "stations" and "trips"
                // class groups.
                //
                // In an SVG things are plotted in "painter" mode: the order of the elements is the order in which they
                // appear in the document body. This is the default behavior when we use "append"; we don't want that.
                // Hence we use this group, selected by id, and the d3 "insert" method (with the :first-child CSS
                // selector) to prepend the path instead.
                //
                // Afterwards the lines are added to this group by "append", causing them to appear in order and---
                // critically---overplot one another.
                //
                // cf. http://stackoverflow.com/questions/26234636/d3-js-prepend-similar-to-jquery-prepend
                //
                // The plotted trips are placed inside of this element later on.
                d3.select("#display-elements")
                                                .insert("g", ":first-child")
                                                .attr("id", "trips");
                // Paint the legend display element.
                paintLegendDisplay();
                // Paint the time controls display element.
                paintTimeControls();
                // The first time the incrementer (below) is fired it shifts to one minute after the current time, and
                // *then* checks if it needs to draw anything. This will leave out any trips that occur at exactly the
                // starting minute of the visualization. To include these, we fire the painter event for them manually
                // first.
                fireLinePainters();
                // Set up the timer tick event.
                // That signals its own end, eventually, calling exitVisualizationAnimation() below.
                interval_id = window.setInterval(incrementTimer, tick_time);

            }

            // Cleans up after the visualization is done.
            function exitVisualizationAnimation() {
                window.clearInterval(interval_id);
                plotStations();
                repaintNonAnimatedDisplayElements();  // TODO: Implement!
            }

            ////////////
            // LEGEND //
            ////////////
            // These methods handle the legend display element. The legend (1) tells users what color means what and
            // (2) allows them to toggle dislaying one category of trips, the other category of trips, or both.

            function paintLegendDisplay() {

                // Before we proceed, we generate the text label we're putting in the box.
                var to_text = null;
                var from_text = null;
                var selection_size = Object.keys(selected_stations).length;
                if (viz_mode == "stations-animation" && selection_size > 1) {
                    from_text = "Trips from Selected Stations"; to_text = "Trips to Selected Stations";
                }
                else if (viz_mode == "stations-animation" && selection_size == 1) {
                    from_text = "Trips from Selected Station"; to_text = "Trips to Selected Station"
                }
                else if (viz_mode == "bikes-animation" && selection_size > 1) {
                    from_text = "Bicycles Outbound from Selected Stations";
                    to_text = "Bicycles Inbound to Selected Stations";
                }
                else if (viz_mode == "bikes-animation" && selection_size == 1) {
                    from_text = "Bicycles Outbound from Selected Station";
                    to_text = "Bicycles Inbound to Selected Station";
                }

                // Now paint the element.
                // Note: the display element is drawn on the HTML map canvas level, not the SVG level. This is
                // because it's rather difficult to get an SVG box into the top right corner, but trivial to
                // do so in HTML.
                d3.select("#map-canvas").append("div")
                        .attr({
                            "id": "legend-display"
                        })
                        .style({
                            "position": "absolute",
                            "top": "20px",
                            "right": "20px",
//                            "width": "220px",
                            "background": "white",
                            "border-radius": "5px",
                            "text-align": "right",
                            "cursor": "pointer",
                            "padding": "10px",
                            "opacity": 0
                        })
                        .transition()
                        .duration(1000)
                        .style("opacity", 1);
                d3.select("#legend-display").append("div")
                        .attr("id", "to-legend-display-block")
                        .style("margin-bottom", "30px")
                        .on("mouseover", function() {
                            enableMouseoverHighlightType("to");
                        })
                        .on("mouseout", function() {
                            disableMouseoverHighlightType("to");
                        })
                        .on("click", function() {
                            clickToggleHighlightType("to")
                        });
                d3.select("#legend-display").append("div")
                        .attr("id", "from-legend-display-block")
                        .style("margin-top", "30px")
                        .on("mouseover", function() {
                            enableMouseoverHighlightType("from");
                        })
                        .on("mouseout", function() {
                            disableMouseoverHighlightType("from");
                        })
                        .on("click", function() {
                            clickToggleHighlightType("from")
                        });
                d3.select("#to-legend-display-block")
                        .append("div")
                        .attr("id", "to-legend-circle")
                        .style({
                            "width": "20px",
                            "height": "20px",
                            "border-radius": "10px",
                            "background": "steelblue",
                            "float": "left",
                            "margin-right": "20px"
                        });
                d3.select("#to-legend-display-block")
                        .append("div")
                        .style({
                            "float": "right",
                            "font-family": "Roboto",
                            "font-weight": "bold",
                            "font-size": "14px"
                        })
                        .text(to_text);
                d3.select("#from-legend-display-block")
                        .append("div")
                        .attr("id", "from-legend-circle")
                        .style({
                            "width": "20px",
                            "height": "20px",
                            "border-radius": "10px",
                            "background": "#b47846",
                            "float": "left",
                            "margin-right": "20px"
                        });
                d3.select("#from-legend-display-block")
                        .append("div")
                        .style({
                            "float": "right",
                            "font-family": "Roboto",
                            "font-weight": "bold",
                            "font-size": "14px"
                        })
                        .text(from_text);
            }

            ///////////////////////
            // TYPE HIGHLIGHTERS //
            ///////////////////////
            // These methods handle what happens when you highlight elementy by type using the legend.

            // Global variables for whether or not the viz is in highlighted modes.
            var highlight_to = false;
            var highlight_from = false;

            // Helper monkey-patch function for bringing selections to the front. Wrapped by bringTripLinesToFront().
            // cf. http://bl.ocks.org/eesur/4e0a69d57d3bfc8a82c2
            // cf. http://stackoverflow.com/questions/14167863/how-can-i-bring-a-circle-to-the-front-with-d3
            d3.selection.prototype.moveToFront = function() {
                return this.each(function(){
                    this.parentNode.appendChild(this);
                });
            };

            // Helper monkey-patch function for bringing selections back.
            // cf. the same.
            d3.selection.prototype.moveToBack = function() {
                return this.each(function() {
                    var firstChild = this.parentNode.firstChild;
                    if (firstChild) {
                        this.parentNode.insertBefore(this, firstChild);
                    }
                });
            };

            // Helper function which brings trip-lines of the given type to the front of the view.
            function bringTripLinesToFront(type) {
                d3.selectAll(".trip-line-" + type).moveToFront();
            }

            // Creates a highlight, based on the status of the highlight flags above (does *not* set these flags
            // itself!)
            function highlightType(type) {
                if (type == "to") {
                    d3.selectAll(".trip-line-to").attr("stroke", "steelblue");
                    if (!highlight_from) {
                        d3.selectAll(".trip-line-from").attr("stroke", "#d7b599");
                    }
                }
                if (type == "from") {
                    d3.selectAll(".trip-line-from").attr("stroke", "#b47846");
                    if (!highlight_to) {
                        d3.selectAll(".trip-line-to").attr("stroke", "#99bbd7");
                    }
                }
                bringTripLinesToFront(type);
            }

            // Removes a type highlight.
            function unhighlightType(type) {
                if (type == "to") {
                    d3.selectAll(".trip-line-to").attr("stroke", "#99bbd7");
                }
                if (type == "from") {
                    d3.selectAll(".trip-line-from").attr("stroke", "#d7b599");
                }
            }

            function enableMouseoverHighlightType(type) {
                // first manipulate the display elements.
                var new_color = null;
                if (type == "to") { new_color = "steelblue"; } else { new_color = "#b47846" }
                d3.select("#" + type + "-legend-display-block")
                        .style("color", new_color);
                d3.select("#" + type + "-legend-circle")
                        .style("border", "2px solid black");
                // Actually enable the highlight.
                if (type == "to" && !highlight_to) {
                    highlightType(type);
                } else if (type == "from" && !highlight_from) {
                    highlightType(type);
                }
            }

            function disableMouseoverHighlightType(type) {
                if ((type == "to" && !highlight_to) || (type == "from" && !highlight_from)) {
                    d3.select("#" +type + "-legend-circle")
                            .style("border", null);
                    // Actually disable the highlight.
                    unhighlightType(type);
                }
                d3.select("#" +type + "-legend-display-block").style("color", null);
            }

            function clickToggleHighlightType(type) {
                if (type == "to") {
                    highlight_to = !highlight_to;
                } else {
                    highlight_from = !highlight_from;
                }
                if ((type == "to" && highlight_to) || (type == "from" && highlight_from)) {
                    highlightType(type);
                } else if ((type == "to" && !highlight_to) || (type == "from" && !highlight_from)) {
                    unhighlightType(type);
                }
            }

            ///////////////////////
            // PATH HIGHLIGHTERS //
            ///////////////////////
            // These methods handle highlighting an individual trip or trip-set, and their implementation vis-a-vis
            // path hovering and clicking.

            // In order for highlighting to function as expected, we need to kill the color-fade transition.
            // Otherwise when highlighting a path which is fading away, one of two things with happen: either (1)
            // it will force-fade from the highlighted color to the fade color, or (2) it will ignore highlighting
            // until the line is done being drawn.
            //
            // The trouble is that if we cancel any arbitrary transition at the time that this function is called,
            // we might be cancelling the initial draw transition, which we DON'T want. We have to be smart, and
            // only cancel a transition of it is the fade transition.
            //
            // In order to do that I embedded a property into the path's datum called `fading-anim`, a boolean
            // storing whether or not the fade transition is currently active. If it is not, then we do nothing---
            // highlights will work as expected in that case. If it is, then we cancel the transition before
            // enabling the highlighter.
            //
            // An alternative approach might be to overplot the path with a highlighted version of itself, but that
            // would have its own problems.
            function dropFadingTransition(selected_path) {
                if (selected_path.datum()['fading-anim'] == true) {
                    selected_path.transition();  // cancels the fading transition, if one is present.
                    selected_path.datum()['fading-anim'] = false;
                }
            }

            // Highlights an individual path and also posts that highlighted path's card.
            // This is used directly when in stations-animation viz_mode, and via highlightPaths() when in
            // bikes-animation viz_mode.
            function highlightPath(selected_path) {
                dropFadingTransition(selected_path);
                selected_path.moveToFront();  // move the current element to the front (monkey-patched).
                if (selected_path.datum()['type'] == "to") {
                    selected_path.attr("stroke", "#1a3043");
                } else {
                    selected_path.attr("stroke", "#432d1a");
                }
            }

            // Undoes the above.
            function unhighlightPath(selected_path) {
                if (selected_path.datum()['type'] == "to") {
                    if(!highlight_to) {
                        selected_path.attr("stroke", "#99bbd7");
                    } else {
                        selected_path.attr("stroke", "steelblue");
                    }
                } else {
                    if(!highlight_from) {
                        selected_path.attr("stroke", "#d7b599");
                    }
                    else {
                        selected_path.attr("stroke", "#b47846");
                    }
                }
            }

            // This wraps highlightPath() for multi-highlight in bikes mode.
            function highlightPaths() {
                var selected_path = d3.select(this);
                var sel_bikeid = selected_path.datum()['bikeid'];
                var selected_trips = d3.selectAll(".trip-line").filter(function(d) {
                    return d['bikeid'] == sel_bikeid;
                });
                selected_trips.each(function(selected_path) {
                    var selected_trip = d3.select(this);
                    highlightPath(selected_trip);
                });
            }

            // Reverses the above.
            function unhighlightPaths() {
                var selected_path = d3.select(this);
                var sel_bikeid = selected_path.datum()['bikeid'];
                var selected_trips = d3.selectAll(".trip-line").filter(function(d) {
                    return d['bikeid'] == sel_bikeid;
                });
                selected_trips.each(function(selected_path) {
                    var selected_trip = d3.select(this);
                    unhighlightPath(selected_trip);
                });
            }

            // This wraps highlightPath() for highlighting in stations mode.
            function highlightSinglePath(selected_trip) {
                highlightPath(d3.select(this));
            }

            // This wraps unhighlightPath() for highlighting in stations mode.
            function unhighlightSinglePath(selected_trip) {
                unhighlightPath(d3.select(this));
            }

            ///////////////////
            // TIME CONTROLS //
            ///////////////////
            // Deals with the basic time controls located under the timer.

            // Whether or not the visualization is paused.
            var paused = false;

            // Paints the time controls on the screen.
            function paintTimeControls() {
                d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "100px",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto",
                            "opacity": 0,
                            "cursor": "pointer"
                        })
                        .attr("id", "time-controls")
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1
                        });

                d3.select("#time-controls").append("button")
                        .style({
                            "font-size": "14px",
                            "font-weight": "bold",
                            "padding": "5px"
                        })
                        .attr("id", "btn-time-controls-slower")
                        .attr("type", "button")
                        .attr("class", "btn")
                        .text("«")
                        .on("click", slowDown);

                d3.select("#time-controls").append("button")
                        .style({
                            "font-size": "12px",
                            "font-weight": "bold",
                            "padding": "5px"
                        })
                        .attr("id", "btn-time-controls-pause")
                        .attr("type", "button")
                        .attr("class", "btn")
                        .text("❚❚")
                        .on("click", togglePausePlay);


                d3.select("#time-controls").append("button")
                        .style({
                            "font-size": "14px",
                            "font-weight": "bold",
                            "padding": "5px"
                        })
                        .attr("id", "btn-time-controls-faster")
                        .attr("class", "btn")
                        .text("»")
                        .on("click", speedUp)
            }

            // Slows down time.
            function slowDown() {
                tick_time += 50;
                console.log(tick_time);
                cycleTimer();
            }

            // Speeds up time.
            function speedUp() {
                if (tick_time >= 50) {
                    tick_time -= 50;
                    cycleTimer();
                } else if (tick_time == 50) {
                    tick_time = 25;
                    cycleTimer();
                }
                // otherwise tick_time == 25, which is already blazingly fast. do nothing.
                console.log(tick_time);
            }

            // Cycles timer to use a new tick_time.
            function cycleTimer() {
                window.clearInterval(interval_id);
                if (current_time.format('h:mm A') != end_time.format('h:mm A')) {
                    interval_id = window.setInterval(incrementTimer, tick_time);
                }
            }

            // Toggles between pausing and playing.
            function togglePausePlay() {
                // Pause.
                paused = !paused;
                if (paused) { window.clearInterval(interval_id); } else { cycleTimer(); }
                // Change display.
                var butt = d3.select("#btn-time-controls-pause");
                if (paused) { butt.text("▶"); } else { butt.text("❚❚"); }
            }

            //////////////////////
            // STATIONS TRIGGER //
            //////////////////////

            // The station_counters object is a data structure which holds on to station-level information about the
            // number of arrivals to and departures from each of the stations which is visible in the animation as a
            // source or sink of trips. In bikes mode, this means that these stations were endpoints or startpoints for
            // bike-days. In stations mode, this means that these stations were endpoints or startpoints for individual
            // trips.
            //
            // The data is stored in the form: {'<station id>': {'to': <n>, 'from': <n>}}
            var station_counters = {};

            // This method is called at the beginning of a path being drawn on-screen with a kind = start argument, and
            // at the same time with a kind = end argument once a path is done being drawn. The actual path is passed as
            // a selection in the `selection` parameter. This method takes this data and logs it into the
            // station_counters variable.
            //
            // I worked out plotting the stations on arrival (at least, in stations mode) but this turned out to have
            // very poor performance characteristics. So I left it for the end of the visualization.
            function pathEvent(event_kind, selection) {
                var station_id = null;
                console.log(event_kind);
                console.log(viz_mode);
                if ((event_kind == "start") && (viz_mode == "stations-animation")) {
                    // First, attach the data to the `station_counters` tracking variable.
                    station_id = selection['start station id'];
                    station_counters[station_id] = {};
                    station_counters[station_id]['from'] += 1;
                } else if ((event_kind == "end") && (viz_mode == "stations-animation")) {
                    station_id = selection['end station id'];
                    station_counters[station_id] = {};
                    station_counters[station_id]['to'] += 1;
                } else if ((event_kind == "start") && (viz_mode == "bikes-animation")) {
                    station_id = selection['start station id'];
                    station_counters[station_id] = {};
                } else if ((event_kind == "end") && (viz_mode == "bikes-animation")) {
                    station_id = selection['end station id'];
                    station_counters[station_id] = {};
                }
            }

            // TODO: Implement!
            // Plots the stations visited by paths at the end of a viz.
            function plotStations() {
                // If the station is one of our selected stations, no special animations are necessary.
                var selected_station_keys = Object.keys(selected_stations);
                var target_station_keys = Object.keys(station_counters);
                var target_stations = d3.selectAll(".station-unselected").filter(function (d) {
                    return (d['station id'] in target_station_keys) && !(d['station id'] in selected_station_keys);
                });
                console.log(target_stations);
                target_stations.each(function() {
                    d3.select(this)
                            .attr("r", 0)
                            .attr("fill-opacity", 1)
                            .transition(5000)
                            .attr("r", 2.5 * scale_factor);
                    });
            }

            // Wrappers to get around http://stackoverflow.com/questions/31524847/d3-js-pass-variable-into-function.
            function pathStartEvent(selection) { pathEvent('start', selection); }
            function pathEndEvent(selection) { pathEvent('end', selection); }

            ////////////////////
            // LINE PLOPPING //
            ///////////////////
            // Both the animation zoomer and the rugplot use line plopping functions from this section. These just plop
            // a line on the page without bothering to animate it.

            // Copy of code from fireLinePainter().
            function plopLine(tripdata, trip_type) {
                // TODO: Implement!
            }

            // Removes a single line, given its data. Used by the rugplot selector!
            function removeLine(tripdata) {
                // TODO: Implement!
            }

            /////////////
            // RUGPLOT //
            /////////////
            // TODO: Implement!

            /////////////////
            // MAIN METHOD //
            /////////////////
            // Everything else above is scoped within functions; those functions are called by the following external
            // main method, in the order needed to get things working.
            //
            // This routine is called when the page is first loaded. But, critically, it is *also* called whenver the
            // page needs to be rerendered---which means, when using Leaflet, whenever the page is zoomed. This is done
            // by D3SvgLeaflet.
            //
            // Thus is we want something to work with zoom, we have to implement what would happen when the map is
            // zoomed *here*.
            //
            // To do that we use a few global variables as flags and specific methods written for the purpose for
            // implementation.
            if (viz_mode == 'intro-animation') {
                viz_mode = 'intro';
                runIntroAnimation();
            }
            // Or correct the existing elements to match the display. This is necessary because by default, whenever
            // the map is zoomed D3SvgOverlay keeps the elements on the map at the same scale as the original ones, but
            // of course that's not what we want.
            //
            // So we have to implement station scaling ourselves, manually.
            else {
                // Rescale (scale_factor is a global).
                scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.0625);
                // Correct the displays.
                rerenderStations();
                // Fade out the intro paths, if we haven't already.
                fadeOutSamplerPaths();
            }
        });

        /////////////
        // RUNTIME //
        /////////////
        // That was a d3SvgOverlay callback, the execution of which is handled by this one-liner.
        mapOverlay.addTo(map);
    </script>
</body>
</html>