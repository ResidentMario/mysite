<!--
    --- NOW ---
    TODO: Assigning data to the elements of the selection once the viz is launched.
    TODO: Loading screen in-and-out for how long that process takes.

    --- LATER ---
    TODO: Animate a line.
    TODO: Create a clock.
    TODO: Put those two things together.
-->
<!DOCTYPE html>
<html>
<head>
    <title>A Day in the Life of CitiBike</title>

    <style type="text/css">
        html { height: 100% }
        body { height: 100%; margin: 0; padding: 0 }
        #map-canvas { height: 100% }
        /* Note that I use a CSS control to change the cursor from a draggy hand to a regular one as well in order to */
        /* keep users from thinking it is interactive at the beginning. */
        /* This is necessary because to keep from distractions the intro animation has zoom and pan disabled. */
        /*.leaflet-container {*/
            /*cursor: default !important;*/
        /*}*/
        /* Station tooltip */
        .station-tip {
            line-height: 1.25;
            padding: 12px;
            background: whitesmoke;
            color: black;
            border-radius: 2px;
            font-family: Roboto;
            border:1px solid #999;
        }
        /* Pure CSS buttons! From http://cssdeck.com/labs/purely-css. Blue one first. */
        button.btn {
            display: inline-block;
            color: #666;
            background-color: #eee;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
            cursor: pointer;
        }

        button.btn:hover {
            background-color: #e3e3e3;
            border-color: rgba(0,0,0,0.5);
        }

        button.btn:active {
            background-color: #CCC;
            border-color: rgba(0,0,0,0.9);
        }

        button.btn-disabled {
            display: inline-block;
            color: #aaa;
            border-color: #aaa;
            background: #e3e3e3;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
        }

        button.btn.btn-blue {
            background-color: #699DB6;
            border-color: rgba(0,0,0,0.3);
            text-shadow: 0 1px 0 rgba(0,0,0,0.5);
            color: #FFF;
        }
        button.btn.btn-blue:hover {
            background-color: #4F87A2;
            border-color: rgba(0,0,0,0.5);
        }
        button.btn.btn-blue:active {
            background-color: #3C677B;
            border-color: rgba(0,0,0,0.9);
        }
    </style>


    <link href='https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css'
    	rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
</head>
<body>

    <div id="map-canvas"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="/static/js/d3.v3.js"></script>
    <script src="/static/js/L.D3SvgOverlay.js"></script>
    <script src="https://d3js.org/d3-queue.v3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment.js"></script>
    <script>

        /////////////////////////
        // MAP INITIALIZATION  //
        /////////////////////////
        // About:
        // The map is Leaflet goodness, with all drawings and animations implemented on top using L.d3SvgOverlay.
        //

        // Initializes the basemap. Disable animations.
        var map = L.map("map-canvas", {
            zoomControl: false,  // Zooming and scrolling disabled to start with, it turns back on later.
            scrollWheelZoom: false,
            minZoom: 11
        });
        // Using Leaflet's fitBounds method ensures that the resultant map contains all of the points on all display
        // devices. The precise points were arrived at by the high scientific method of guess-and-check.
        map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]]);
        // More disabling things.
        map.dragging.disable();
        map.keyboard.disable();
        map.doubleClickZoom.disable();
        // I also use a CSS control to change the cursor from a draggy hand to a regular one as well in order to
        // keep users from thinking it is interactive at the beginning.
        // Gib tile layer.
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);
        // Thx.

        //////////////////////
        // GLOBAL VARIABLES //
        //////////////////////
        // Variables declared inside of the draw callback will be reset every time that the map zoom level is changed.
        // Therefore variables which have to exist outside of the draw state live here.

        // While the intro animation is playing we disable map interactions because d3SvgOverlay doesn't handle
        // having to redraw things that are partially animated. So we store a global for this purpose. Once the
        // intro animation is done we switch this to false and enable interactions. Future draws refer this variable
        // when deciding how to repaint.
        var is_intro_anim = true;

        // The scale factor global is used while redrawing to keep interactive display elements at a reasonable size at
        // all zoom levels. This is necessary because by default d3SvgOverlay will simply keep the objects at the same
        // size at all zoom levels, which causes massive blobs at high zoom levels and tiny specks at low ones.
        var scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.0625);

        // In order to implement the station toggle selection we need to implement a global struct which stores
        // stations selected and the paths that have been drawn associated with them. The structure is thus:
        // {'<first station id>':
        //      { 'station':<first station selection>,
        //        'trips': [<first trip selection>, <second trip selection>, ...]
        //      }
        //  '<second station id>':
        //      { ... }
        //  ...
        // }
        // This data structure is unaware of what the provenance of the trips it stores is, it merely stores them.
        // Accessing trips allows us to do either/or of the two viz modes.
        // They're stored under stations to allow implementing a highlighter later on.
        var selected_stations = {};

        // The current visualization mode.
        var viz_mode = "intro";

        // D3-SVG-Overlay callback wrapper. Leaflet is used only for the base map, all of the programmatic action occurs
        // in d3 code inside of this callback.
        var mapOverlay = L.d3SvgOverlay(function(sel,proj){

            //////////////////////
            // INTRO ANIMATION  //
            //////////////////////
            // Design:
            // For the introduction I wanted to dynamically render a random set of paths (200 of them in the final
            // visualization) before painting the rest of the introductory scene.
            //
            // Implementation:
            // runIntroAnimation() -> paintPathSampler() -> paintPath()
            //                     -> paintBackgroundPanel()
            //                     -> paintStations()
            //                     -> drawInfoBox() [function from the "infobox" section, the intro adds a timeout]
            //                     -> enableInteractions()
            //
            // Notes:
            // * Zooming and panning are disabled while the introduction is playing. They are re-enabled once it's over.
            // * The sample paths fade out as soon as the user zooms in or selects a visualization mode.
            // * The `is_intro_anim` global boolean tells the main scene painter (way below) how to behave.

            // Paints a single sampler path. Accepts a linearray (an array of points) as input, as well as the position
            // of the line being drawn in placement order. paintPathSampler is the method which actually handles the
            // entire path-sampling introductory animation, and it implements this method over a loop to do that.
            function paintPath(linearray, index) {

                // Define the SVG line reprojection function.
                var line = d3.svg.line()
                        .x(function(d) { return proj.latLngToLayerPoint(d).x})
                        .y(function(d) { return proj.latLngToLayerPoint(d).y});

                // Create a path, bind the line array to its __data__, and call line on it to generate the line-code.
                setTimeout(function() {
                    sel.append('path').datum(linearray)
                            .attr({
                                "class": "sample-line",
                                "d": line,
                                "fill": "transparent",
                                "stroke": "white",
                                "stroke-width": 3,
                                "vector-effect": "non-scaling-stroke"
                            })
                            .transition()
                            .duration(2500)
                            .attr({
                                "stroke": "#99bbd7"
                            })
                }, 25*i);
            }

            // Paint all of the sampler paths. Wraps paintPath(), above, with consideration removing old paths.
            // The data file itself, `sample_trips.json`, was generated using Python.
            function paintPathSampler() {
                // Remove all of the existing paths first, otherwise we keep old ones!
                sel.selectAll('path').remove();

                d3.json("../../static/post_assets/citibike/sample_trips.json", function (data) {
                    for(i=0; i<data.length; i++) {
                        paintPath(data[i], i);
                    }
                });
            }

            // Paints all of the stations on the map.
            function paintStations() {
                d3.csv("../../static/post_assets/citibike/june_22_station_metadata.csv", function(error, dataset) {
                    if (error) throw error;

                    setTimeout(function() {
                        sel
                                .append("g")
                                .selectAll("circle")
                                .data(dataset)
                                .enter()
                                .append("circle")
                                .attr({
                                    "class": "station station-unselected",
                                    "cx": function (d) { return proj.latLngToLayerPoint([d.latitude, d.longitude]).x },
                                    "cy": function (d) { return proj.latLngToLayerPoint([d.latitude, d.longitude]).y },
                                    "r": 0,
                                    "stroke": "white",
                                    "stroke-width": 2,
                                    "cursor": "pointer",
                                    "fill": function(d) {
                                        if(d['kind'] == 'active') {
                                            return "#3f75a2";
                                        }
                                        else if(d['kind'] == 'inactive') {
                                            return "#a7a7a7";
                                        }
                                    },
                                    "fill-opacity": 1,
                                    "stroke-opacity": 1
                                })
                                .on('mouseover', function(d, i){
                                    d3.select(this)
                                        .attr({
                                            "stroke-width": 4,
                                            "r": 10,
                                            "id": "hovered-station"
                                        });
                                    showTooltip(d);
                                })
                                .on('mouseout', function(d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 2,
                                                "r": 5,
                                                "id": null
                                            });
                                    hideTip();
                                })
                                .on("click", toggleStation)
                                .transition()
                                .duration(500)
                                .attr({
                                    "r": 5
                                })
                    }, 6000);
                });
            }

            // Enables interactions (meant to be used once the animation is done playing).
            function enableInteractions() {
                is_intro_anim = false;
                d3.select("#map-canvas").style("cursor", "pointer");
                map.dragging.enable();
                map.keyboard.enable();
                map.scrollWheelZoom.enable();
            }

            // Disables interactions. Actually not currently used during the intro, used instead during the later
            // actual visualization.
            function disableInteractions() {
                d3.select("#map-canvas").style("cursor", "default");
                map.dragging.disable();
                map.keyboard.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            }


            // This function runs the intro animation.
            function runIntroAnimation() {
                d3.select("#map-canvas").style("cursor", "default");  // change cursor to the default while animating.
                paintPathSampler();  // Animate the sample paths.
                paintStations();  // Animate the stations.
                setTimeout(function() {
                    paintIntroInfo();  // Append the intro text box. This method is from the Info Box code segment.
                }, 6000);
                setTimeout(function() {
                    enableInteractions();
                    d3.select("#map-canvas").style("cursor", null);  // then back to a grabby hand after
                }, 6000);
            }

            //////////////
            // INFO BOX //
            //////////////
            // Design:
            // Handles the information display on the left-hand side. A different one is created every time the viz
            // mode is switched.
            //
            // Implementation:
            // {paintIntroInfo(), paintStationsInfo(), paintBikesInfo()} -> drawInfoBox()
            //

            // Draws the info box. This method is used by the information pane painters (there are three, one for each
            // viz mode: intro, stations, bikes). Since the height and width and whatnot of the display depends on the
            // device, all of the sizing for this box are calculated with respect to extrema on the map.
            function drawInfoBox() {
                // Remove any pre-existing ones, we re-draw every time we return.
                d3.select("#description-block").remove();

                // Create the container.
                d3.select("#map-canvas")
                        .append("div")
                        .attr("id", "description-block")
                        .style({
                            "position": "absolute",
                            "width": "400px",
                            // It's easiest to just let height be whatever height the whole thing ends up at.
//                                "height": (proj.latLngToLayerPoint([40.70122128,-74.01234218]).y -
//                                            proj.latLngToLayerPoint([40.784642, -73.970002]).y) + "px",
                            "top": proj.latLngToLayerPoint([40.784642, -73.970002]).y + "px",
                            "left": proj.latLngToLayerPoint([40.704556, -74.026222]).x - 400 - 20 + "px",
                            // ^ (point in the Hudson river) - (width of the box) - (bit of additional padding).
                            "background": "#fff",
                            "border-radius": "25px",
                            "opacity": 0.0,
                            "padding": "10px",
                            "font-family": "Roboto",
                            "text-align": "center",
                            "cursor": "default"
                        })
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1.0
                        });

                // Append title.
                d3.select("#description-block")
                        .append("div")
                        .style({
                            "font-size": "24px",
                            "font-weight": "bold"
                        })
                        .text("A Day in the Life of CitiBike");

            }

            // Paints the introductory info box.
            function paintIntroInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["intro"]);
                });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Stations")
                        .on("click", function() {
                            switchToStationsMode();
                        });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Bikes")
                        .on("click", function() {
                            switchToBikesMode();
                        });

            }

            // Removes everything from the selection. Used by the Reset GUI element. It's factored out because it's
            // common to both functions.
            // This really ought to be in the station selection block, but for some reason when it's there it breaks my
            // build.
            function clearSelection() {
                d3.selectAll(".station-selected").attr({
                    "stroke": "white",
                    "class": "station"
                });
                selected_stations = {};
                updateSelectionDisplay();
                updateResetAndLaunchButtonStyles();
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // bounces you back to the intro. It's factored out because it's common to both functions.
            function appendMenuGoBack(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Go Back")
                        .on("click", function() {
                            switchToIntroMode();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // launches the visualization. It's factored out because it's common to both functions.
            function appendMenuLaunch(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "id": "launch-button",
                            "class": function() {
                                var selection_size = Object.keys(selected_stations).length;
                                if(selection_size == 0) {
                                    return "btn-disabled";
                                }
                                else {
                                    return "btn btn-blue";
                                }
                            }
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Launch")
                        .on("click", function() {
                                initLoadingScreen();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // removes all of the stations in your current selection. It's factored out because it's common to both
            // functions.
            function appendMenuReset(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": function() {
                                if(Object.keys(selected_stations).length == 0) {
                                    return "btn-disabled";
                                }
                                else {
                                    return "btn"
                                }
                            },
                            "id": "reset-button"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Reset")
                        .on("click", function() {
                            clearSelection();  // in the station selection section.
                            updateSelectionDisplay();  // Necessary in case there are preexisting selections.
                            updateResetAndLaunchButtonStyles();
                        });
            }

            // Paints the stations info box.
            function paintStationsInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["stations"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            // Paints the bikes info box.
            function paintBikesInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["bikes"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            ///////////////////////
            // STATION SELECTION //
            ///////////////////////
            // Design:
            // This code handles when a user clicks on a station, uses the box select, or hits clear selection.
            //

            // Now the function itself. As a UX decision I decided to split *generating* a selection from plotting its
            // data. I did this to allow doing selections on the introduction pane, before the user chooses a
            // visualization mode. For a UX standpoint this is necessary because not having that there would make it
            // awkward for the user to realize that they can click on things later.
            //
            // From a developer standpoint this means that selected_stations can contain just stations without any data
            // bound to them, necessitating that, on triggering a visualization mode, we call a function which checks
            // and binds data to the current selection, if necessary. It also requires a global flag for what mode
            // the visualization is in, intro or stations or bikes. This is `viz_mode` above.
            function toggleStation(d) {
                var sel_station = d3.select(this);
                // Do nothing if the station is inactive.
                if(d['kind'] == 'active') {
                    if(!(d['station id'] in selected_stations)) {
                        // Station is not currently in the selection, so add it.
                        // Notice the semantics: trips are stored as two dict-indexed arrays, one of trips in and one
                        // of trips out.
                        selected_stations[d['station id']] = {'to': null, 'from': null};
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "black", "class": "station station-selected"});
                    }
                    else {
                        // The element is already in the selection, so remove it (this is a toggle after all).
                        delete selected_stations[d['station id']];
                        // Update the display element.
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "white", "class": "station station-unselected"});
                    }
                    // Update the display elements.
                    updateSelectionDisplay();
                    updateResetAndLaunchButtonStyles();
                }
            }

            // The following helper method updates the selection display.
            // It is called by toggleStation() whenever a station is added to the selection or removed from it.
            function updateSelectionDisplay() {
                var selection_size = Object.keys(selected_stations).length;
                if(selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#selection-display").remove();
                }
                else {
                    // If there's just one selection that means we just selected our first station.
                    // So create the display element.
                    // Note: the display element is drawn on the HTML map canvas level, not the SVG level. This is
                    // because it's rather difficult to get an SVG box into the top right corner, but trivial to
                    // do so in HTML.
                    d3.select("#selection-display").remove();
                    d3.select("#map-canvas").append("div")
                            .attr({
                                "id": "selection-display"
                            })
                            .style({
                                "position": "absolute",
                                "top": "20px",
                                "right": "20px",
                                "width": "400px",
                                "background": "transparent",
//                                    "border": "1px solid black",
                                "text-align": "right"
                            })
                            .html(function(d) {
                                // The string is fairly complicated to write, so let's break it up into parts.
                                // First we put down the part that always displays, the selection size.
                                // Since the presence or lack thereof of that pesky "s" depends on the pluralization we
                                // have to deal with that first.
                                var s = "";
                                if(selection_size > 1) {
                                    s = "s";
                                }
                                // Now the basic display string.
                                var display =
                                        "<div style='font-family:Roboto; line-height:1'>" +
                                        "<div style='font-weight: bold; font-size: 24px; '>" +
                                         selection_size + " Station" + s + " Selected</div>";
                                // Ok, if we are on the introductory screen this is all we need.
                                if(viz_mode == "intro") {
                                    return display;
                                }
                                // If not then we have to do more work. For starters, get all of the selected elements.
                                // (when an element is selected it is added to the station-selected class list. This
                                //  is done explicitly for the purposes of this here function!)
                                var all_selected_stations_data = d3.selectAll(".station-selected").data();
                                // We're going to need a trip counter.
                                var total_trips = 0;
                                // Now we'll need to iterate through these and add something which is dependent on the
                                // mode. If we're in stations mode we need "all trips". If we're in bikes mode we need
                                // "outbound trips" plus "inbound trips".
                                var i = 0;
                                if(viz_mode == "stations") {
                                    for(i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['all trips'];
                                    }
                                }
                                else if(viz_mode == "bikes") {
                                    for(i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['outbound trips'];
                                        total_trips += +all_selected_stations_data[i]['inbound trips'];
                                    }
                                }
                                // Write this data to the string.
                                display += "<br/>" + total_trips + " trips will be plotted." + "</div>";
                                return display;
                                // Write the string.
//                                return "<div style='font-weight: bold; font-size: 24px; font-family:Roboto;'>" +
//                                        selection_size + " Station" + s + " Selected</div><br/>" +
//                                        trips_to_be_visualized_line
                            });
                }

            }

            // Sets or unsets updateButton clickiness based on whether or not there are stations are in the current
            // selection.
            function updateResetAndLaunchButtonStyles() {
                var selection_size = Object.keys(selected_stations).length;
                if(selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#reset-button").attr({"class": "btn-disabled"});
                    d3.select("#launch-button").attr({"class": "btn-disabled"});
                }
                else {
                    d3.select("#reset-button").attr({"class": "btn"});
                    d3.select("#launch-button").attr({"class": "btn btn-blue"});
                }
            }

            /////////////
            // TOOLTIP //
            /////////////
            // Design:
            // On hovering over one of the stations a tooltip displays with information on what that station is. Super
            // useful for navigation purposes.
            //
            // Implementation:
            // I originally hoped I could use d3.tip for this (and implemented it that way) but it turns out that
            //  d3.tip cannot deal with projections at all, so I have to hard-code my own tooltip design.
            //

            // Displays the appropriate tooltip for the selected station.
            function showTooltip(d) {
                var sel_station = d3.select("#hovered-station");
                d3.select("#map-canvas")
                        .append("div")
                        .attr({"class": "station-tip"})
                        .style({
                            "position": "absolute",
                            // TODO: Fix this broken-ass positioning...
//                            "top": +sel_station.attr("cy") - +30 + "px",
//                            "left": +sel_station.attr("cx") + +20 + "px"
                            "top": proj.latLngToLayerPoint([d['latitude'], d['longitude']]).y -
                            (30 * scale_factor) + "px",
                            "left": proj.latLngToLayerPoint([d['latitude'], d['longitude']]).x +
                            (20 * scale_factor) + "px"
                        })
                        .html(function() {
                            var underline = null;
                            if(d['kind'] == 'inactive') {
                                underline = "Out of Service" + "</span></div>";
                            }
                            else {
                                if(viz_mode == 'intro') {
                                    var bikes_out_in = +d['bikes outbound'] + +d['bikes inbound'];
                                    // Pluralize!
                                    var bikes_out_s = "s";
                                    var trips_s = "s";
                                    if(+d['all trips'] == 1) {
                                        trips_s = "";
                                    }
                                    if(bikes_out_in == 1) {
                                        bikes_out_s = "";
                                    }

                                    underline = d['all trips'] +
                                            " trip" + trips_s + " to or from here.<br/>" +
                                            bikes_out_in + " bike" + bikes_out_s + " began or ended the day here." +
                                            "</span></div>";
                                }
                                else if(viz_mode == 'stations') {
                                    underline = d['incoming trips'] +
                                    " trips to this station.<br/>"
                                    + d['outgoing trips']
                                    + " trips from this station.<br/>"
//                                    + d['all trips'] + " trips total."
                                    + "</span></div>";
                                }
                                else if(viz_mode == 'bikes') {
                                    // Pluralize!
                                    var out_s = "s";
                                    if(+d['bikes outbound'] == 1) {
                                        out_s = "";
                                    }
                                    underline =  d['bikes outbound'] +
                                    " bike" + out_s + " started the day here.<br/> " +
                                    d['bikes inbound'] + " ended it here." +
                                    "</span></div>";
                                }
                            }
                            return "<div style='text-align:center'>" +
                                "<span style='font-weight:bold; font-size:16px;'>" +
                                d['station name'] +
                                "</span><br/><span style='font-size:12px;'>" + underline;
                        });
            }

            // Removes the tooltip.
            function hideTip() {
                d3.select(".station-tip").remove();
            }

            ////////////////////
            // MODAL SWITCHES //
            ////////////////////
            // Design:
            // When you click the modal buttons, this code takes you to that visualization mode. What happens then is
            // TBD.
            //

            // Once you have gotten as far as selecting a visualization type the sampler paths go bye-bye.
            function fadeOutSamplerPaths() {
                var sample_lines = d3.selectAll(".sample-line");
                sample_lines
                        .transition()
                        .duration(2000)
                        .style({"opacity": 0})
                        .remove();
            }

            function switchToBikesMode() {
                viz_mode = "bikes";
                fadeOutSamplerPaths();
                paintBikesInfo();
                applyBikesModeColorMap();
                updateSelectionDisplay();
            }

            function switchToStationsMode() {
                viz_mode = "stations";
                fadeOutSamplerPaths();
                paintStationsInfo();
                applyStationsModeColorMap();
                updateSelectionDisplay();
            }

            function switchToIntroMode() {
                viz_mode = "intro";
                paintIntroInfo();
                applyIntroColorMap();
                updateSelectionDisplay();
            }

            //////////////////
            // COLORIZATION //
            //////////////////
            // Design:
            // These functions define the colormap for each of the different viz types.
            //

            function applyBikesModeColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else if (d['delta bikes'] < 0) {
                                    return "#d8b365";
                                }
                                else if(d['delta bikes'] >= 0){
                                    return "#3f75a2";
                                }
//                                else {
//                                    return "#3f75a2";
//                                }
                            }
                        });
            }

            function applyStationsModeColorMap() {
//                var stations_color_scale = d3.scale.linear().domain([0, 1500]).range(["#a7c4dd", "#152635"]);
                var all_data = d3.selectAll(".station").data().map(function(d) { return d['all trips']});
                var stations_color_scale = d3.scale.quantile().domain(all_data).range(['lightsteelblue',
                    'steelblue', '#2b4f6d']);

                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else {
                                    return stations_color_scale(d['all trips']);
                                }
                            }
                        });
            }

            function applyIntroColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else {
                                    return "#3f75a2";
                                }
                            }
                        });
            }

            //////////////////
            // RE-RENDERING //
            //////////////////
            // Design:
            // These methods handle tweaking stations and jittering the hover tooltip when the map is zoomed, so that
            // everything stays in the correct place and has the correct size.

            function rerenderStations() {
                d3.selectAll(".station")
                        .attr({
                            "r": 5 * scale_factor,
                            "stroke-width": 2 * scale_factor
                        })
                        .on('mouseover', function(d, i){
                            d3.select(this)
                                .attr({
                                    "stroke-width": 4 * scale_factor,
                                    "r": 10 * scale_factor,
                                    "id": "hovered-station"
                                });
                            showTooltip(d);
                        })
                        .on('mouseout', function(d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 2 * scale_factor,
                                        "r": 5 * scale_factor,
                                        "id": null
                                    });
                            hideTip();
                        });
            }

            ////////////////////
            // LOADING SCREEN //
            ////////////////////
            // Design:
            // Data is actually bound the selection at the moment when the Launch button is hit.
            // A loading screen keeps the user busy while they wait.
            // This section implements that loading screen.

            // Nicely fades out the data elements present in the selection which are not present in the animation.
            function unpaintNonAnimatedDisplayElements() {
                d3.select("#description-block").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#selection-display").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // When the visualization is done, replace the data elements back onto the screen.
            function repaintNonAnimatedDisplayElements() {
                return null;
                // TODO: Implement.
            }

            // Emits the non-data elements of the loading screen: the background panel, "Loading..." text, and the cute
            // loading animation.
            function paintLoadingElements() {
                // Fade in the background panel.
                var panel = sel.append("rect")
                        .attr({
                            "fill": "black",
                            "width": "100%",
                            "height": "100%",
                            "fill-opacity": 0.0,
                            "id": "background-panel"
                        })
                        .transition()
                        .duration(1000)
                        .attr({
                            "fill-opacity": 0.5
                        });

                var loader = d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50%",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto"
                        })
                        .attr("id", "loader");

                loader.append("img")
                        .attr({
                            "src": "http://127.0.0.1:5000/static/post_assets/citibike/loading-ring.svg"
                        });

                loader.append("div")
                        .style({
                            "margin": "auto",
                            "font-weight": "bold",
                            "font-size": "30px",
                            "color": "white",
                            "font-family": "Roboto"
                        })
                        .text("Loading...");
            }

            // Kills the loading screen. Called once the API data is properly bound, as a part of exitLoadingScreen.
            function unpaintLoadingScreen() {
                d3.select("#loader").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#background-panel").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Makes the actual API calls which bind the data to the selected stations' struct.
            // The data is fed in asynchronously. I have to play around with it to understand what that means for me.
            // Notice that this function remaps the API tripset identifiers from the ones specific to the ask mode to
            // simply "to" and "from" keys. This simplifies calling on this data later, as it eliminates having to
            // check the viz mode and adopt the accessor key to match it, as we have had to do here.
            //
            // The "callback" parameter should be filled with the function which will run once the data bind is done---
            // in our case this is unpaintLoadingScreen!
            function bindData(call_this_once_done) {
                var api_paths = null;
                if (viz_mode == "bikes") {
                    api_paths = ["bike-inbounds", "bike-outbounds"]
                }
                else {
                    api_paths = ["incoming-trips", "outgoing-trips"]
                }
                var q = d3.queue();
                for (let key in selected_stations) {
                    if (selected_stations.hasOwnProperty(key)) {
                        q.defer(function (callback) {
                            console.log("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[0] +
                                    "/id/" + key);
                            d3.json("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[0] +
                                    "/id/" + key, function (data) {
                                selected_stations[key]['to'] = data;
                                callback(null, data);
                            });
                        });
                        q.defer(function (callback) {
                            console.log("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[1] +
                                    "/id/" + key);
                            d3.json("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[1] +
                                    "/id/" + key, function (data) {
                                selected_stations[key]['from'] = data;
                                callback(null, data);
                            });
                        })
                    }
                }
                q.awaitAll(function (error) {
                    if (error) throw error;
                    console.log(selected_stations);
                    call_this_once_done();
                });
            }

            // Removes non-selected stations from the map.
            function unpaintUnselectedStations() {
                d3.selectAll(".station-unselected")
                        .transition()
                        .duration(2500)
                        .attr({
                            "fill-opacity": 0,
                            "stroke-opacity": 0
                        }) ; // .remove();
                // Disable deselection of selected stations.
                d3.selectAll(".station").on("click", null);
                // Disable hover for the now-hidden stations.
                d3.selectAll(".station-unselected").style("cursor", "default").on("mouseover", null);
            }

            // Transitions the map view back to the default one.
            function resetView() {
                map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]],
                        options={'animate':true});
            }

            //
            // Runners for all these things.
            //

            // Continues the transition by removing the loading screen, dropping non-selected stations, zooming out to
            // a planar view, and fiddling with interactivity. Then hands things off to the visualization runner!
            function exitLoadingScreen() {
                var q = d3.queue();
                function transit(callback) {
                    unpaintLoadingScreen();
                    unpaintUnselectedStations();
                    // Paint the timer ahead of launch.
                    paintTimer();
                    // Wait a little bit to allow painters to finish and the user to realize that this is happening.
                    setTimeout(function() {
                        callback(null);
                    }, 4000);
                }
                q.defer(transit);
                q.await(function(error) {
                    incrementTimer();  // TODO: Remove this once done testing!
                    launchVisualizationAnimation();
                });
//                unpaintLoadingScreen();
//                unpaintUnselectedStations();
//                launchVisualizationAnimation();  // Run the show!
            }

            // First part of the transition. exitLoadingScreen finishes the job after data has loaded.
            function initLoadingScreen() {
                disableInteractions();
                resetView();
                unpaintNonAnimatedDisplayElements();
                paintLoadingElements();
                bindData(exitLoadingScreen);
            }

            //////////////////////////////
            // TRIP ANIMATION --- TIMER //
            //////////////////////////////
            // These methods operate the trip animation timer element.

            // The current time is stored here. Note that we initialize to be the visualized date, as of this script's
            // execution datetime, but that forward part is irrelevant to us.
            var time = moment.utc(0);

            // Creates the on-screen timer element.
            function paintTimer() {
                d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50px",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto",
                            "opacity": 0
                        })
                        .attr("id", "timer")
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1
                        });

                d3.select("#timer").append("div")
                        .style({
                            "font-size": "40px",
                            "font-weight": "bold"
                        })
                        .attr("id", "timer-text")
//                        .text("12:00 PM");
                        .text(time.format('h:mm A'));
            }

            // Removes the trip animation timer element.
            function unpaintTimer() {
                d3.select("#timer").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Moves the timer forward one tick (one minute).
            function incrementTimer() {
                console.log("Hi I was used!");
                console.log(time);
                time = time.add(1, 'minutes');
                console.log(time.format('HH:MM A'));
                console.log(time);
                console.log(time.format('HH:MM A'));
                d3.select("#timer-text").text(time.format('h:mm A'));  // Update display.
                fireLinePainters();
            }

            // Does the line drawing stuff.
            function fireLinePainters() {
                // TODO: Implement!
            }

            /////////////////////
            // TRIP ANIMATIONS //
            /////////////////////

            function launchVisualizationAnimation() {

                // Testing...
                window.setInterval(incrementTimer, 1000);

                var data = d3.range(11).map(function(){return Math.random()*10});

                var x = d3.scale.linear().domain([0, 10]).range([0, 700]);
                var y = d3.scale.linear().domain([0, 10]).range([10, 290]);

                var line = d3.svg.line()
                        .interpolate("cardinal")
                        .x(function(d,i) {return x(i);})
                        .y(function(d) {return y(d);});


                var path = sel.append("path")
                      .attr("d", line(data))
                      .attr("stroke", "steelblue")
                      .attr("stroke-width", "2")
                      .attr("fill", "none");

                var totalLength = path.node().getTotalLength();

                path
                        .attr("stroke-dasharray", totalLength + " " + totalLength)
                        .attr("stroke-dashoffset", totalLength)
                        .transition()
//                        .ease()
                        .duration(2000)
                        .attr("stroke-dashoffset", 0);

                // TODO: Implement!
//                var draw_fps = 60;
//                var timer = setInterval(incrementLineDraw, 1000 / draw_fps);
            }

            /////////////////
            // MAIN METHOD //
            /////////////////
            // This is the method runs the drawer.
            // Either run the intro animation...
            if(is_intro_anim) {
                runIntroAnimation();
            }
            // Or correct the existing elements to match the display. This is necessary because by default, whenever
            // the map is zoomed D3SvgOverlay keeps the elements on the map at the same scale as the original ones, but
            // of course that's not what we want.
            //
            // So we have to implement station scaling ourselves, manually.
            else {
                // Rescale (scale_factor is a global).
                scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.0625);
                // Correct the displays.
                rerenderStations();
                // Fade out the intro paths, if we haven't already.
                fadeOutSamplerPaths();
            }
        });

        /////////////
        // RUNTIME //
        /////////////
        // That was a d3SvgOverlay callback, the execution of which is handled by this one-liner.
        mapOverlay.addTo(map);
    </script>
</body>
</html>