<!--
    --- NOW ---
    TODO: Move line animation behind the currently selected station(s).
    TODO: Add color transition to trip viz line animation. (surprisingly hard; cf. https://bl.ocks.org/mbostock/5348789)
    TODO: Change color of line animations based on line type (in or out, to or from).

    --- LATER ---
    TODO: Figure out zoom!
    TODO: Create a trip animations plotting rugplot at the bottom of the screen.
    TODO: Add a legend for type to the top-left corner.
    TODO: On hovering over the types in the legend, highlight trips of this type.
    TODO: On clicking on a type in the legend, toggle displaying only trips of that type.
    TODO: On hovering over a trip, highlight that trip.
    TODO: On hovering over a trip, display a tooltip with information about that trip.
    TODO: On clicking on a trip, highlight that bike's set of trips.
    TODO: Add a "Next Trip" element to the timer display element.
    TODO: Paint stations in trip viz line animation.
    TODO: Add slower/faster controls.
-->
<!DOCTYPE html>
<html>
<head>
    <title>A Day in the Life of CitiBike</title>

    <style type="text/css">
        html { height: 100% }
        body { height: 100%; margin: 0; padding: 0 }
        #map-canvas { height: 100% }
        /* Note that I use a CSS control to change the cursor from a draggy hand to a regular one as well in order to */
        /* keep users from thinking it is interactive at the beginning. */
        /* This is necessary because to keep from distractions the intro animation has zoom and pan disabled. */
        /*.leaflet-container {*/
            /*cursor: default !important;*/
        /*}*/
        /* Station tooltip */
        .station-tip {
            line-height: 1.25;
            padding: 12px;
            background: whitesmoke;
            color: black;
            border-radius: 2px;
            font-family: Roboto;
            border:1px solid #999;
        }
        /* Pure CSS buttons! From http://cssdeck.com/labs/purely-css. Blue one first. */
        button.btn {
            display: inline-block;
            color: #666;
            background-color: #eee;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
            cursor: pointer;
        }

        button.btn:hover {
            background-color: #e3e3e3;
            border-color: rgba(0,0,0,0.5);
        }

        button.btn:active {
            background-color: #CCC;
            border-color: rgba(0,0,0,0.9);
        }

        button.btn-disabled {
            display: inline-block;
            color: #aaa;
            border-color: #aaa;
            background: #e3e3e3;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
        }

        button.btn.btn-blue {
            background-color: #699DB6;
            border-color: rgba(0,0,0,0.3);
            text-shadow: 0 1px 0 rgba(0,0,0,0.5);
            color: #FFF;
        }
        button.btn.btn-blue:hover {
            background-color: #4F87A2;
            border-color: rgba(0,0,0,0.5);
        }
        button.btn.btn-blue:active {
            background-color: #3C677B;
            border-color: rgba(0,0,0,0.9);
        }
    </style>


    <link href='https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css'
    	rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
</head>
<body>

    <div id="map-canvas"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="/static/js/d3.v3.js"></script>
    <script src="/static/js/L.D3SvgOverlay.js"></script>
    <script src="https://d3js.org/d3-queue.v3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment.js"></script>
    <script>

        /////////////////////////
        // MAP INITIALIZATION  //
        /////////////////////////
        // About:
        // The map is Leaflet goodness, with all drawings and animations implemented on top using L.d3SvgOverlay.
        //

        // Initializes the basemap. Disable animations.
        var map = L.map("map-canvas", {
            zoomControl: false,  // Zooming and scrolling disabled to start with, it turns back on later.
            scrollWheelZoom: false,
            minZoom: 11
        });
        // Using Leaflet's fitBounds method ensures that the resultant map contains all of the points on all display
        // devices. The precise points were arrived at by the high scientific method of guess-and-check.
        map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]]);
        // More disabling things.
        map.dragging.disable();
        map.keyboard.disable();
        map.doubleClickZoom.disable();
        // I also use a CSS control to change the cursor from a draggy hand to a regular one as well in order to
        // keep users from thinking it is interactive at the beginning.
        // Gib tile layer.
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
            subdomains: 'abcd',
            maxZoom: 19
        }).addTo(map);
        // Thx.

        //////////////////////
        // GLOBAL VARIABLES //
        //////////////////////
        // Variables declared inside of the draw callback will be reset every time that the map zoom level is changed.
        // Therefore variables which have to exist outside of the draw state live here.

        // While the intro animation is playing we disable map interactions because d3SvgOverlay doesn't handle
        // having to redraw things that are partially animated. So we store a global for this purpose. Once the
        // intro animation is done we switch this to false and enable interactions. Future draws refer this variable
        // when deciding how to repaint.
        var is_intro_anim = true;

        // The scale factor global is used while redrawing to keep interactive display elements at a reasonable size at
        // all zoom levels. This is necessary because by default d3SvgOverlay will simply keep the objects at the same
        // size at all zoom levels, which causes massive blobs at high zoom levels and tiny specks at low ones.
        var scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.0625);

        // In order to implement the station toggle selection we need to implement a global struct which stores
        // stations selected and the paths that have been drawn associated with them.
        // In the first part of the view, before launching any visualization, this data just contains a list of all of
        // the selected station ids. The actual data is populated once the user hits the Go button; to see how things
        // are structured at that point see bindData(), way below.
        var selected_stations = {};

        // The current visualization mode.
        var viz_mode = "intro";

        // D3-SVG-Overlay callback wrapper. Leaflet is used only for the base map, all of the programmatic action occurs
        // in d3 code inside of this callback.
        var mapOverlay = L.d3SvgOverlay(function(sel,proj) {

            //////////////////////
            // INTRO ANIMATION  //
            //////////////////////
            // Design:
            // For the introduction I wanted to dynamically render a random set of paths (200 of them in the final
            // visualization) before painting the rest of the introductory scene.
            //
            // Implementation:
            // runIntroAnimation() -> paintPathSampler() -> paintPath()
            //                     -> paintBackgroundPanel()
            //                     -> paintStations()
            //                     -> drawInfoBox() [function from the "infobox" section, the intro adds a timeout]
            //                     -> enableInteractions()
            //
            // Notes:
            // * Zooming and panning are disabled while the introduction is playing. They are re-enabled once it's over.
            // * The sample paths fade out as soon as the user zooms in or selects a visualization mode.
            // * The `is_intro_anim` global boolean tells the main scene painter (way below) how to behave.

            // Paints a single sampler path. Accepts a linearray (an array of points) as input, as well as the position
            // of the line being drawn in placement order. paintPathSampler is the method which actually handles the
            // entire path-sampling introductory animation, and it implements this method over a loop to do that.
            function paintPath(linearray, index) {

                // Define the SVG line reprojection function.
                var line = d3.svg.line()
                        .x(function (d) {
                            return proj.latLngToLayerPoint(d).x
                        })
                        .y(function (d) {
                            return proj.latLngToLayerPoint(d).y
                        });

                // Create a path, bind the line array to its __data__, and call line on it to generate the line-code.
                setTimeout(function () {
                    sel.append('path').datum(linearray)
                            .attr({
                                "class": "sample-line",
                                "d": line,
                                "fill": "transparent",
                                "stroke": "white",
                                "stroke-width": 3,
                                "vector-effect": "non-scaling-stroke"
                            })
                            .transition()
                            .duration(2500)
                            .attr({
                                "stroke": "#99bbd7"
                            })
                }, 25 * i);
            }

            // Paint all of the sampler paths. Wraps paintPath(), above, with consideration removing old paths.
            // The data file itself, `sample_trips.json`, was generated using Python.
            function paintPathSampler() {
                // Remove all of the existing paths first, otherwise we keep old ones!
                sel.selectAll('path').remove();

                d3.json("../../static/post_assets/citibike/sample_trips.json", function (data) {
                    for (i = 0; i < data.length; i++) {
                        paintPath(data[i], i);
                    }
                });
            }

            // Paints all of the stations on the map.
            function paintStations() {
                d3.csv("../../static/post_assets/citibike/june_22_station_metadata.csv", function (error, dataset) {
                    if (error) throw error;

                    setTimeout(function () {
                        sel
                                .append("g")
                                .attr("id", "display-elements")
                                .append("g")
                                .attr("id", "stations")  // groups are for display---cf. launchVisualizationAnimation()
                                .selectAll("circle")
                                .data(dataset)
                                .enter()
                                .append("circle")
                                .attr({
                                    "class": "station station-unselected",
                                    "cx": function (d) {
                                        return proj.latLngToLayerPoint([d.latitude, d.longitude]).x
                                    },
                                    "cy": function (d) {
                                        return proj.latLngToLayerPoint([d.latitude, d.longitude]).y
                                    },
                                    "r": 0,
                                    "stroke": "white",
                                    "stroke-width": 2,
                                    "cursor": "pointer",
                                    "fill": function (d) {
                                        if (d['kind'] == 'active') {
                                            return "#3f75a2";
                                        }
                                        else if (d['kind'] == 'inactive') {
                                            return "#a7a7a7";
                                        }
                                    },
                                    "fill-opacity": 1,
                                    "stroke-opacity": 1,
                                    "z-index": 10
                                })
                                .on('mouseover', function (d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 4,
                                                "r": 10,
                                                "id": "hovered-station"
                                            });
                                    showTooltip(d);
                                })
                                .on('mouseout', function (d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 2,
                                                "r": 5,
                                                "id": null
                                            });
                                    hideTip();
                                })
                                .on("click", toggleStation)
                                .transition()
                                .duration(500)
                                .attr({
                                    "r": 5
                                })
                    }, 6000);
                });
            }

            // Enables interactions (meant to be used once the animation is done playing).
            function enableInteractions() {
                is_intro_anim = false;
                d3.select("#map-canvas").style("cursor", "pointer");
                map.dragging.enable();
                map.keyboard.enable();
                map.scrollWheelZoom.enable();
            }

            // Disables interactions. Actually not currently used during the intro, used instead during the later
            // actual visualization.
            function disableInteractions() {
                d3.select("#map-canvas").style("cursor", "default");
                map.dragging.disable();
                map.keyboard.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            }


            // This function runs the intro animation.
            function runIntroAnimation() {
                d3.select("#map-canvas").style("cursor", "default");  // change cursor to the default while animating.
                paintPathSampler();  // Animate the sample paths.
                paintStations();  // Animate the stations.
                setTimeout(function () {
                    paintIntroInfo();  // Append the intro text box. This method is from the Info Box code segment.
                }, 6000);
                setTimeout(function () {
                    enableInteractions();
                    d3.select("#map-canvas").style("cursor", null);  // then back to a grabby hand after
                }, 6000);
            }

            //////////////
            // INFO BOX //
            //////////////
            // Design:
            // Handles the information display on the left-hand side. A different one is created every time the viz
            // mode is switched.
            //
            // Implementation:
            // {paintIntroInfo(), paintStationsInfo(), paintBikesInfo()} -> drawInfoBox()
            //

            // Draws the info box. This method is used by the information pane painters (there are three, one for each
            // viz mode: intro, stations, bikes). Since the height and width and whatnot of the display depends on the
            // device, all of the sizing for this box are calculated with respect to extrema on the map.
            function drawInfoBox() {
                // Remove any pre-existing ones, we re-draw every time we return.
                d3.select("#description-block").remove();

                // Create the container.
                d3.select("#map-canvas")
                        .append("div")
                        .attr("id", "description-block")
                        .style({
                            "position": "absolute",
                            "width": "400px",
                            // It's easiest to just let height be whatever height the whole thing ends up at.
//                                "height": (proj.latLngToLayerPoint([40.70122128,-74.01234218]).y -
//                                            proj.latLngToLayerPoint([40.784642, -73.970002]).y) + "px",
                            "top": proj.latLngToLayerPoint([40.784642, -73.970002]).y + "px",
                            "left": proj.latLngToLayerPoint([40.704556, -74.026222]).x - 400 - 20 + "px",
                            // ^ (point in the Hudson river) - (width of the box) - (bit of additional padding).
                            "background": "#fff",
                            "border-radius": "25px",
                            "opacity": 0.0,
                            "padding": "10px",
                            "font-family": "Roboto",
                            "text-align": "center",
                            "cursor": "default"
                        })
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1.0
                        });

                // Append title.
                d3.select("#description-block")
                        .append("div")
                        .style({
                            "font-size": "24px",
                            "font-weight": "bold"
                        })
                        .text("A Day in the Life of CitiBike");

            }

            // Paints the introductory info box.
            function paintIntroInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["intro"]);
                });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Stations")
                        .on("click", function () {
                            switchToStationsMode();
                        });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Bikes")
                        .on("click", function () {
                            switchToBikesMode();
                        });

            }

            // Removes everything from the selection. Used by the Reset GUI element. It's factored out because it's
            // common to both functions.
            // This really ought to be in the station selection block, but for some reason when it's there it breaks my
            // build.
            function clearSelection() {
                d3.selectAll(".station-selected").attr({
                    "stroke": "white",
                    "class": "station"
                });
                selected_stations = {};
                updateSelectionDisplay();
                updateResetAndLaunchButtonStyles();
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // bounces you back to the intro. It's factored out because it's common to both functions.
            function appendMenuGoBack(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Go Back")
                        .on("click", function () {
                            switchToIntroMode();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // launches the visualization. It's factored out because it's common to both functions.
            function appendMenuLaunch(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "id": "launch-button",
                            "class": function () {
                                var selection_size = Object.keys(selected_stations).length;
                                if (selection_size == 0) {
                                    return "btn-disabled";
                                }
                                else {
                                    return "btn btn-blue";
                                }
                            }
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Launch")
                        .on("click", function () {
                            initLoadingScreen();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // removes all of the stations in your current selection. It's factored out because it's common to both
            // functions.
            function appendMenuReset(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": function () {
                                if (Object.keys(selected_stations).length == 0) {
                                    return "btn-disabled";
                                }
                                else {
                                    return "btn"
                                }
                            },
                            "id": "reset-button"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Reset")
                        .on("click", function () {
                            clearSelection();  // in the station selection section.
                            updateSelectionDisplay();  // Necessary in case there are preexisting selections.
                            updateResetAndLaunchButtonStyles();
                        });
            }

            // Paints the stations info box.
            function paintStationsInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["stations"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            // Paints the bikes info box.
            function paintBikesInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["bikes"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            ///////////////////////
            // STATION SELECTION //
            ///////////////////////
            // Design:
            // This code handles when a user clicks on a station, uses the box select, or hits clear selection.
            //

            // Now the function itself. As a UX decision I decided to split *generating* a selection from plotting its
            // data. I did this to allow doing selections on the introduction pane, before the user chooses a
            // visualization mode. For a UX standpoint this is necessary because not having that there would make it
            // awkward for the user to realize that they can click on things later.
            //
            // From a developer standpoint this means that selected_stations can contain just stations without any data
            // bound to them, necessitating that, on triggering a visualization mode, we call a function which checks
            // and binds data to the current selection, if necessary. It also requires a global flag for what mode
            // the visualization is in, intro or stations or bikes. This is `viz_mode` above.
            function toggleStation(d) {
                var sel_station = d3.select(this);
                // Do nothing if the station is inactive.
                if (d['kind'] == 'active') {
                    if (!(d['station id'] in selected_stations)) {
                        // Station is not currently in the selection, so add it.
                        // Notice the semantics: trips are stored as two dict-indexed arrays, one of trips in and one
                        // of trips out.
                        selected_stations[d['station id']] = {'to': null, 'from': null};
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "black", "class": "station station-selected"});
                    }
                    else {
                        // The element is already in the selection, so remove it (this is a toggle after all).
                        delete selected_stations[d['station id']];
                        // Update the display element.
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "white", "class": "station station-unselected"});
                    }
                    // Update the display elements.
                    updateSelectionDisplay();
                    updateResetAndLaunchButtonStyles();
                }
            }

            // The following helper method updates the selection display.
            // It is called by toggleStation() whenever a station is added to the selection or removed from it.
            function updateSelectionDisplay() {
                var selection_size = Object.keys(selected_stations).length;
                if (selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#selection-display").remove();
                }
                else {
                    // If there's just one selection that means we just selected our first station.
                    // So create the display element.
                    // Note: the display element is drawn on the HTML map canvas level, not the SVG level. This is
                    // because it's rather difficult to get an SVG box into the top right corner, but trivial to
                    // do so in HTML.
                    d3.select("#selection-display").remove();
                    d3.select("#map-canvas").append("div")
                            .attr({
                                "id": "selection-display"
                            })
                            .style({
                                "position": "absolute",
                                "top": "20px",
                                "right": "20px",
                                "width": "400px",
                                "background": "transparent",
//                                    "border": "1px solid black",
                                "text-align": "right"
                            })
                            .html(function (d) {
                                // The string is fairly complicated to write, so let's break it up into parts.
                                // First we put down the part that always displays, the selection size.
                                // Since the presence or lack thereof of that pesky "s" depends on the pluralization we
                                // have to deal with that first.
                                var s = "";
                                if (selection_size > 1) {
                                    s = "s";
                                }
                                // Now the basic display string.
                                var display =
                                        "<div style='font-family:Roboto; line-height:1'>" +
                                        "<div style='font-weight: bold; font-size: 24px; '>" +
                                        selection_size + " Station" + s + " Selected</div>";
                                // Ok, if we are on the introductory screen this is all we need.
                                if (viz_mode == "intro") {
                                    return display;
                                }
                                // If not then we have to do more work. For starters, get all of the selected elements.
                                // (when an element is selected it is added to the station-selected class list. This
                                //  is done explicitly for the purposes of this here function!)
                                var all_selected_stations_data = d3.selectAll(".station-selected").data();
                                // We're going to need a trip counter.
                                var total_trips = 0;
                                // Now we'll need to iterate through these and add something which is dependent on the
                                // mode. If we're in stations mode we need "all trips". If we're in bikes mode we need
                                // "outbound trips" plus "inbound trips".
                                var i = 0;
                                if (viz_mode == "stations") {
                                    for (i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['all trips'];
                                    }
                                }
                                else if (viz_mode == "bikes") {
                                    for (i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['outbound trips'];
                                        total_trips += +all_selected_stations_data[i]['inbound trips'];
                                    }
                                }
                                // Write this data to the string.
                                display += "<br/>" + total_trips + " trips will be plotted." + "</div>";
                                return display;
                                // Write the string.
//                                return "<div style='font-weight: bold; font-size: 24px; font-family:Roboto;'>" +
//                                        selection_size + " Station" + s + " Selected</div><br/>" +
//                                        trips_to_be_visualized_line
                            });
                }

            }

            // Sets or unsets updateButton clickiness based on whether or not there are stations are in the current
            // selection.
            function updateResetAndLaunchButtonStyles() {
                var selection_size = Object.keys(selected_stations).length;
                if (selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#reset-button").attr({"class": "btn-disabled"});
                    d3.select("#launch-button").attr({"class": "btn-disabled"});
                }
                else {
                    d3.select("#reset-button").attr({"class": "btn"});
                    d3.select("#launch-button").attr({"class": "btn btn-blue"});
                }
            }

            /////////////
            // TOOLTIP //
            /////////////
            // Design:
            // On hovering over one of the stations a tooltip displays with information on what that station is. Super
            // useful for navigation purposes.
            //
            // Implementation:
            // I originally hoped I could use d3.tip for this (and implemented it that way) but it turns out that
            //  d3.tip cannot deal with projections at all, so I have to hard-code my own tooltip design.
            //

            // Displays the appropriate tooltip for the selected station.
            function showTooltip(d) {
                var sel_station = d3.select("#hovered-station");
                d3.select("#map-canvas")
                        .append("div")
                        .attr({"class": "station-tip"})
                        .style({
                            "position": "absolute",
                            // TODO: Fix this broken-ass positioning...
//                            "top": +sel_station.attr("cy") - +30 + "px",
//                            "left": +sel_station.attr("cx") + +20 + "px"
                            "top": proj.latLngToLayerPoint([d['latitude'], d['longitude']]).y -
                            (30 * scale_factor) + "px",
                            "left": proj.latLngToLayerPoint([d['latitude'], d['longitude']]).x +
                            (20 * scale_factor) + "px"
                        })
                        .html(function () {
                            var underline = null;
                            if (d['kind'] == 'inactive') {
                                underline = "Out of Service" + "</span></div>";
                            }
                            else {
                                if (viz_mode == 'intro') {
                                    var bikes_out_in = +d['bikes outbound'] + +d['bikes inbound'];
                                    // Pluralize!
                                    var bikes_out_s = "s";
                                    var trips_s = "s";
                                    if (+d['all trips'] == 1) {
                                        trips_s = "";
                                    }
                                    if (bikes_out_in == 1) {
                                        bikes_out_s = "";
                                    }

                                    underline = d['all trips'] +
                                            " trip" + trips_s + " to or from here.<br/>" +
                                            bikes_out_in + " bike" + bikes_out_s + " began or ended the day here." +
                                            "</span></div>";
                                }
                                else if (viz_mode == 'stations') {
                                    underline = d['incoming trips'] +
                                            " trips to this station.<br/>"
                                            + d['outgoing trips']
                                            + " trips from this station.<br/>"
//                                    + d['all trips'] + " trips total."
                                            + "</span></div>";
                                }
                                else if (viz_mode == 'bikes') {
                                    // Pluralize!
                                    var out_s = "s";
                                    if (+d['bikes outbound'] == 1) {
                                        out_s = "";
                                    }
                                    underline = d['bikes outbound'] +
                                            " bike" + out_s + " started the day here.<br/> " +
                                            d['bikes inbound'] + " ended it here." +
                                            "</span></div>";
                                }
                            }
                            return "<div style='text-align:center'>" +
                                    "<span style='font-weight:bold; font-size:16px;'>" +
                                    d['station name'] +
                                    "</span><br/><span style='font-size:12px;'>" + underline;
                        });
            }

            // Removes the tooltip.
            function hideTip() {
                d3.select(".station-tip").remove();
            }

            ////////////////////
            // MODAL SWITCHES //
            ////////////////////
            // Design:
            // When you click the modal buttons, this code takes you to that visualization mode. What happens then is
            // TBD.
            //

            // Once you have gotten as far as selecting a visualization type the sampler paths go bye-bye.
            function fadeOutSamplerPaths() {
                var sample_lines = d3.selectAll(".sample-line");
                sample_lines
                        .transition()
                        .duration(2000)
                        .style({"opacity": 0})
                        .remove();
            }

            function switchToBikesMode() {
                viz_mode = "bikes";
                fadeOutSamplerPaths();
                paintBikesInfo();
                applyBikesModeColorMap();
                updateSelectionDisplay();
            }

            function switchToStationsMode() {
                viz_mode = "stations";
                fadeOutSamplerPaths();
                paintStationsInfo();
                applyStationsModeColorMap();
                updateSelectionDisplay();
            }

            function switchToIntroMode() {
                viz_mode = "intro";
                paintIntroInfo();
                applyIntroColorMap();
                updateSelectionDisplay();
            }

            //////////////////
            // COLORIZATION //
            //////////////////
            // Design:
            // These functions define the colormap for each of the different viz types.
            //

            function applyBikesModeColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else if (d['delta bikes'] < 0) {
                                    return "#d8b365";
                                }
                                else if (d['delta bikes'] >= 0) {
                                    return "#3f75a2";
                                }
//                                else {
//                                    return "#3f75a2";
//                                }
                            }
                        });
            }

            function applyStationsModeColorMap() {
//                var stations_color_scale = d3.scale.linear().domain([0, 1500]).range(["#a7c4dd", "#152635"]);
                var all_data = d3.selectAll(".station").data().map(function (d) {
                    return d['all trips']
                });
                var stations_color_scale = d3.scale.quantile().domain(all_data).range(['lightsteelblue',
                    'steelblue', '#2b4f6d']);

                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else {
                                    return stations_color_scale(d['all trips']);
                                }
                            }
                        });
            }

            function applyIntroColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else {
                                    return "#3f75a2";
                                }
                            }
                        });
            }

            //////////////////
            // RE-RENDERING //
            //////////////////
            // Design:
            // These methods handle tweaking stations and jittering the hover tooltip when the map is zoomed, so that
            // everything stays in the correct place and has the correct size.

            function rerenderStations() {
                d3.selectAll(".station")
                        .attr({
                            "r": 5 * scale_factor,
                            "stroke-width": 2 * scale_factor
                        })
                        .on('mouseover', function (d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 4 * scale_factor,
                                        "r": 10 * scale_factor,
                                        "id": "hovered-station"
                                    });
                            showTooltip(d);
                        })
                        .on('mouseout', function (d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 2 * scale_factor,
                                        "r": 5 * scale_factor,
                                        "id": null
                                    });
                            hideTip();
                        });
            }

            ////////////////////
            // LOADING SCREEN //
            ////////////////////
            // Design:
            // Data is actually bound the selection at the moment when the Launch button is hit.
            // A loading screen keeps the user busy while they wait.
            // This section implements that loading screen.

            // Nicely fades out the data elements present in the selection which are not present in the animation.
            function unpaintNonAnimatedDisplayElements() {
                d3.select("#description-block").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#selection-display").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // When the visualization is done, replace the data elements back onto the screen.
            function repaintNonAnimatedDisplayElements() {
                return null;
                // TODO: Implement.
            }

            // Emits the non-data elements of the loading screen: the background panel, "Loading..." text, and the cute
            // loading animation.
            function paintLoadingElements() {
                // Fade in the background panel.
                var panel = sel.append("rect")
                        .attr({
                            "fill": "black",
                            "width": "100%",
                            "height": "100%",
                            "fill-opacity": 0.0,
                            "id": "background-panel"
                        })
                        .transition()
                        .duration(1000)
                        .attr({
                            "fill-opacity": 0.5
                        });

                var loader = d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50%",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto"
                        })
                        .attr("id", "loader");

                loader.append("img")
                        .attr({
                            "src": "http://127.0.0.1:5000/static/post_assets/citibike/loading-ring.svg"
                        });

                loader.append("div")
                        .style({
                            "margin": "auto",
                            "font-weight": "bold",
                            "font-size": "30px",
                            "color": "white",
                            "font-family": "Roboto"
                        })
                        .text("Loading...");
            }

            // Kills the loading screen. Called once the API data is properly bound, as a part of exitLoadingScreen.
            function unpaintLoadingScreen() {
                d3.select("#loader").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#background-panel").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Makes the actual API calls which bind the data elements needed to run the visualization.
            //
            // We populate two data elements here. The first element that we populate is selected_stations, a data
            // struct containing trip information organized thusly:
            //
            // {
            //      <stationid>:
            //          {
            //           'from': [{'geometry': <trip geometry array>, 'properties': <trip properties dict>}, {...}, ...]
            //           'to': [{...}, ...]
            //          },
            //      <...>: {...},
            //      ...
            // }
            //
            // This element contains the information that is used for drawing things. The visualization happens around
            // "ticks" representing minutes, however, and it would be prohibitively expensive to have to check the
            // entire struct for trips happening on the current tick. Instead, I create a lookup table that looks like
            // this:
            //
            // [{'starttime': <moment>,
            //   'stationid': <stationid>,
            //   'type': <from/to>,
            //   'position': <array index>},
            //   {...}]
            //
            // This is `trips_timetable`, below.
            var trips_timetable = [];
            // We'll need to store the current time.
            // The current time is stored here.
            var current_time = moment.utc(0);  // moment.js object
            // It's also useful for us to track what the next time is.
            var next_time = null;  // moment.js object
            // What the current index of interest is.
            var current_index = 0;
            // The time we end everything on.
            var end_time = null;  // moment.js object
            // The interval id assigned to the setInterval instance which runs our timer.
            var interval_id = null;
            // How long a tick lasts (in ms).
            var tick_time = 250;

            // The "callback" parameter should be filled with the function which will run once the data bind is done---
            // in our case this is unpaintLoadingScreen!
            function bindData(call_this_once_done) {
                // The calls to the API are handled by an asynchronous d3 queue, which waits for selected_stations to
                // finish populating before proceeding before continuing. The code below is what executes that.
                var api_paths = null;
                if (viz_mode == "bikes") {
                    api_paths = ["bike-inbounds", "bike-outbounds"]
                }
                else {
                    api_paths = ["incoming-trips", "outgoing-trips"]
                }
                var q = d3.queue();
                for (let key in selected_stations) {  // let is needed here due to closure stuff I don't quite get
                    if (selected_stations.hasOwnProperty(key)) {
                        console.log(key);
                        q.defer(function (callback) {
                            console.log("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[0] +
                                    "/id/" + key);
                            d3.json("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[0] +
                                    "/id/" + key, function (data) {
                                selected_stations[key]['to'] = data;
                            });
                            callback(null);
                        });
                        q.defer(function (callback) {
                            console.log("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[1] +
                                    "/id/" + key);
                            d3.json("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[1] +
                                    "/id/" + key, function (data) {
                                selected_stations[key]['from'] = data;
                            });
                            callback(null);
                        });
                    }
                }
                // We wait for all of the data populate. Once that's done, we proceed with creating the timetable, which
                // runs in a single blocking thread, and then with launching the rest of the visualization.
                // Note: var time, declared below, is a moment.js object storing the current time within the viz.
                q.awaitAll(function (error) {
                    if (error) throw error;
                    // Now we create the timetable.
                    var key = null;
                    console.log("Selected stations:");
                    console.log(selected_stations);
                    for(key in selected_stations) {  // let is not necessary here because we are in a blocking thread
                        if (selected_stations.hasOwnProperty(key)) {
                            var types = ['from', 'to'];
                            for(var j = 0; j < types.length; j++) {
                                var type = types[j];
                                for(var k = 0; k < selected_stations[key][type].length; k++) {
                                    var trip = selected_stations[key][type][k];
                                    var starttime = moment(trip['properties']['starttime'], '6/22/2016 hh:mm:ss');
//                                                .format('h:mm A');
//                                        var starttime = String(
//                                                moment(trip['properties']['starttime'], '6/22/2016 hh:mm:ss')
//                                                        .format('h:mm A')
//                                        );
                                    trips_timetable.push({
                                        'starttime': starttime,
                                        'stationid': key,
                                        'type': type,
                                        'position': k
                                    });
                                }
                            }
                        }
                    }
                    // Now we need to sort the timetable. This is done using built-in moment object comparison.
                    trips_timetable = trips_timetable.sort(function(a, b) { return a['starttime'] > b['starttime']; });
                    // Set the next_time parameter.
                    next_time = trips_timetable[0]['starttime'];
                    // Start the viz off at the first trip of the day. (deep copy)
                    current_time = next_time.clone();
                    // Where we end the visualization.
                    var end_ref = trips_timetable[trips_timetable.length - 1];
                    var end_trip = selected_stations[end_ref['stationid']][end_ref['type']][end_ref['position']];
                    end_time = moment(end_trip['properties']['stoptime']);
                    console.log(trips_timetable);
                    // Initialize the loop and continue!
                    call_this_once_done();
                });
            }

            // Removes non-selected stations from the map.
            function unpaintUnselectedStations() {
                d3.selectAll(".station-unselected")
                        .transition()
                        .duration(2500)
                        .attr({
                            "fill-opacity": 0,
                            "stroke-opacity": 0
                        }) ; // .remove();
                // Disable deselection of selected stations.
                d3.selectAll(".station").on("click", null);
                // Disable hover for the now-hidden stations.
                d3.selectAll(".station-unselected").style("cursor", "default").on("mouseover", null);
            }

            // Transitions the map view back to the default one.
            function resetView() {
                map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]],
                        options={'animate':true});
            }

            //
            // Runners for all these things.
            //

            // Continues the transition by removing the loading screen, dropping non-selected stations, zooming out to
            // a planar view, and fiddling with interactivity. Then hands things off to the visualization runner!
            function exitLoadingScreen() {
                var q = d3.queue();
                function transit(callback) {
                    unpaintLoadingScreen();
                    unpaintUnselectedStations();
                    // Paint the timer ahead of launch.
                    paintTimer();
                    // Wait a little bit to allow painters to finish and the user to realize that this is happening.
                    setTimeout(function() {
                        callback(null);
                    }, 1000);
                }
                q.defer(transit);
                q.await(function(error) {
                    launchVisualizationAnimation();
                });
            }

            // First part of the transition. exitLoadingScreen finishes the job after data has loaded.
            function initLoadingScreen() {
                disableInteractions();
                resetView();
                unpaintNonAnimatedDisplayElements();
                paintLoadingElements();
                bindData(exitLoadingScreen);
            }

            //////////////////////////////
            // TRIP ANIMATION --- TIMER //
            //////////////////////////////
            // These methods operate the trip animation timer element.

            // Creates the on-screen timer element.
            function paintTimer() {
                d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50px",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto",
                            "opacity": 0
                        })
                        .attr("id", "timer")
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1
                        });

                d3.select("#timer").append("div")
                        .style({
                            "font-size": "40px",
                            "font-weight": "bold"
                        })
                        .attr("id", "timer-text")
//                        .text("12:00 PM");
                        .text(current_time.format('h:mm A'));
            }

            // Removes the trip animation timer element.
            function unpaintTimer() {
                d3.select("#timer").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Moves the timer forward one tick (one minute) and changes everything that happens as a result.
            function incrementTimer() {
                current_time = current_time.add(1, 'minutes');
                // If we aren't at the end, do stuff.
                if (current_time.format('h:mm A') != end_time.format('h:mm A')) {
                    d3.select("#timer-text").text(current_time.format('h:mm A'));  // Update display.
                    fireLinePainters();
                }
                // If we are at the end, finish and clean up.
                else {
                    exitVisualizationAnimation();
                }
            }

            // Handles the line drawing stuff.
            function fireLinePainters() {
                // We only paint things if next_time indicates that a trip happened this minute.
                if (current_time.format('h:mm A') == next_time.format('h:mm A')) {
                    while(trips_timetable[current_index]['starttime'].format('h:mm A') == next_time.format('h:mm A')) {
                        var curr = trips_timetable[current_index];
                        var tripdata = selected_stations[curr['stationid']][curr['type']][curr['position']];
                        var trip_type = curr['type'];
                        fireLinePainter(tripdata, trip_type);
                        current_index++;
                    }
                    next_time = trips_timetable[current_index]['starttime'];
                }
            }

            // This helper method for `fireLinePainters()`, above, handles actually painting one line.
            // The tripdata parameter is the trip's entry in selected_stations---this contains all of the data about
            // the trip itself. The trip_type parameter is the trip type: to/from.
            function fireLinePainter(tripdata, trip_type) {

                console.log("Fired line painter!");

                var linedata = tripdata['geometry']['coordinates'];
                var duration = moment.duration(
                    moment(tripdata['properties']['stoptime']).diff(moment(tripdata['properties']['starttime']))
                ).asMinutes() * tick_time;
                var c = null;  // the color the trip is initially plotted in.
                var fc = null;  // the color the trip eventually fades to.
                if (trip_type == 'to') { c = "steelblue"; fc = "#c3d7e8" } else { c = "#d8b365"; fc = "#f0e1c3"; }
                console.log(trip_type);
                console.log(c);
                var line = d3.svg.line()
                        .interpolate("cardinal")
                        .x(function(d) { return proj.latLngToLayerPoint(d).x; })
                        .y(function(d) { return proj.latLngToLayerPoint(d).y; });

                console.log(d3.select(".display-elements"));

                // display-elements is the id given to the <g> tag which holds (1) all of the station circle elements
                // that are initialized when the introductory animation is finished and (2) all of the paths that we
                // are now appending underneath them.
                //
                // In an SVG things are plotted in "painter" mode: the order of the elements is the order in which they
                // appear in the document body. This is the default behavior when we use "append"; we don't want that.
                // Hence we use this group, selected by id, and the d3 "insert" method (with the :first-child CSS
                // selector) to prepend the path instead.
                //
                // cf. http://stackoverflow.com/questions/26234636/d3-js-prepend-similar-to-jquery-prepend
//                var path = d3.select("#display-elements").insert("path", ":first-child");
                console.log(d3.select("#display-elements"));
                console.log(d3.select("#display-elements"));

                var path = d3.select("#trips").append("path");
                path
                        .attr({
                            "d": line(linedata),
                            "stroke-width": "3",
                            "fill": "none",
                            "stroke": c
                        });
                var totalLength = path.node().getTotalLength();
                // Plot through the trip time.
                path
                        .attr("stroke-dasharray", totalLength + " " + totalLength)
                        .attr("stroke-dashoffset", totalLength)
                        .transition()
                        .duration(duration)
                        .attr("stroke-dashoffset", 0);
                // Fade color after plotting is done.
                path
                        .transition()
                        .delay(duration)
                        .duration(30 * tick_time)
                        .attr("stroke", fc);
            }

            /////////////////////
            // TRIP ANIMATIONS //
            /////////////////////

            function launchVisualizationAnimation() {
                // Create a new group for the lines.
                // This group is placed before the stations in the document object model so that the lines appear
                // *below* the stations.
                //
                // display-elements is the id given to the <g> tag which holds (1) all of the station circle elements
                // that are initialized when the introductory animation is finished and (2) all of the paths that we
                // are now appending underneath them. These are sorted, respectively, into the "stations" and "trips"
                // class groups.
                //
                // In an SVG things are plotted in "painter" mode: the order of the elements is the order in which they
                // appear in the document body. This is the default behavior when we use "append"; we don't want that.
                // Hence we use this group, selected by id, and the d3 "insert" method (with the :first-child CSS
                // selector) to prepend the path instead.
                //
                // Afterwards the lines are added to this group by "append", causing them to appear in order and---
                // critically---overplot one another.
                //
                // cf. http://stackoverflow.com/questions/26234636/d3-js-prepend-similar-to-jquery-prepend
                //
                // The plotted trips are placed inside of this element later on.
                d3.select("#display-elements")
                                                .insert("g", ":first-child")
                                                .attr("id", "trips");
                console.log("display-elements selection: ");
                console.log(d3.select("#display-elements"));
                console.log("trips selection: ");
                console.log(d3.select("#trips"));
                // The first time the incrementer (below) is fired it shifts to one minute after the current time, and
                // *then* checks if it needs to draw anything. This will leave out any trips that occur at exactly the
                // starting minute of the visualization. To include these, we fire the painter event for them manually
                // first.
                fireLinePainters();
                // Set up the timer tick event.
                // That signals its own end, eventually, calling exitVisualizationAnimation() below.
                interval_id = window.setInterval(incrementTimer, tick_time);

            }

            // Cleans up after the visualization is done.
            function exitVisualizationAnimation() {
                window.clearInterval(interval_id);
                // TODO: Implement!
            }

            /////////////////
            // MAIN METHOD //
            /////////////////
            // This is the method runs the drawer.
            // Either run the intro animation...
            if(is_intro_anim) {
                runIntroAnimation();
            }
            // Or correct the existing elements to match the display. This is necessary because by default, whenever
            // the map is zoomed D3SvgOverlay keeps the elements on the map at the same scale as the original ones, but
            // of course that's not what we want.
            //
            // So we have to implement station scaling ourselves, manually.
            else {
                // Rescale (scale_factor is a global).
                scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.0625);
                // Correct the displays.
                rerenderStations();
                // Fade out the intro paths, if we haven't already.
                fadeOutSamplerPaths();
            }
        });

        /////////////
        // RUNTIME //
        /////////////
        // That was a d3SvgOverlay callback, the execution of which is handled by this one-liner.
        mapOverlay.addTo(map);
    </script>
</body>
</html>