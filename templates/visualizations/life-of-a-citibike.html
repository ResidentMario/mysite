<!--
    --- NOW ---
    TODO: Fix highlighting so that it works in stations mode as well.
    TODO: Allow selecting a random tripset by hitting Space.
    TODO: Allow click-to-hold on the highlighting.
    TODO: Paint stations in trip viz line animation (once finished, with some sort of arrival info).
    TODO: Create transition back to the selection screen after the animation is done.

    --- BUGS ---
    TODO: Fix the multiple-station data bind issue.

    --- LATER ---
    TODO: Create a trip animations plotting rugplot at the bottom of the screen (and associate info with it!).
    TODO: Advanced rugplot ideas: click-to-jump-to-time, drag-to-select-a-time-period, drag-to-left-edge-to-pin.
-->
<!DOCTYPE html>
<html>
<head>
    <title>A Day in the Life of CitiBike</title>

    <style type="text/css">
        html { height: 100% }
        body { height: 100%; margin: 0; padding: 0 }
        #map-canvas { height: 100% }
        /* Note that I use a CSS control to change the cursor from a draggy hand to a regular one as well in order to */
        /* keep users from thinking it is interactive at the beginning. */
        /* This is necessary because to keep from distractions the intro animation has zoom and pan disabled. */
        /*.leaflet-container {*/
            /*cursor: default !important;*/
        /*}*/
        /* Station tooltip */
        .station-tip {
            line-height: 1.25;
            padding: 20px;
            background: white;
            color: black;
            border-radius: 5px;
            font-family: Roboto;
            position: absolute;
            left: 50%;
            transform: translate(-50%,0%);
            /*border:1px solid #999;*/
        }
        /* Pure CSS buttons! From http://cssdeck.com/labs/purely-css. Blue one first. */
        button.btn {
            display: inline-block;
            color: #666;
            background-color: #eee;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
            cursor: pointer;
        }

        button.btn:hover {
            background-color: #e3e3e3;
            border-color: rgba(0,0,0,0.5);
        }

        button.btn:active {
            background-color: #CCC;
            border-color: rgba(0,0,0,0.9);
        }

        button.btn-disabled {
            display: inline-block;
            color: #aaa;
            border-color: #aaa;
            background: #e3e3e3;
            text-transform: uppercase;
            font-size: 12px;
            padding: 10px 30px;
            border-radius: 5px;
            -moz-border-radius: 5px;
            -webkit-border-radius: 5px;
            border: 1px solid rgba(0,0,0,0.3);
            border-bottom-width: 3px;
        }

        button.btn.btn-blue {
            background-color: #699DB6;
            border-color: rgba(0,0,0,0.3);
            text-shadow: 0 1px 0 rgba(0,0,0,0.5);
            color: #FFF;
        }
        button.btn.btn-blue:hover {
            background-color: #4F87A2;
            border-color: rgba(0,0,0,0.5);
        }
        button.btn.btn-blue:active {
            background-color: #3C677B;
            border-color: rgba(0,0,0,0.9);
        }
    </style>


    <link href='https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.css'
    	rel='stylesheet' type='text/css'/>
    <link href='https://fonts.googleapis.com/css?family=Roboto' rel='stylesheet' type='text/css'>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
</head>
<body>

    <div id="map-canvas"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.3/leaflet.js"></script>
    <script src="/static/js/d3.v3.js"></script>
    <script src="/static/js/L.D3SvgOverlay.js"></script>
    <script src="https://d3js.org/d3-queue.v3.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.14.1/moment.js"></script>
    <script>

        /////////////////////////
        // MAP INITIALIZATION  //
        /////////////////////////
        // About:
        // The map is Leaflet goodness, with all drawings and animations implemented on top using L.d3SvgOverlay.
        //

        // Initializes the basemap. Disable animations.
        var map = L.map("map-canvas", {
            zoomControl: false,  // Zooming and scrolling disabled to start with, it turns back on later.
            scrollWheelZoom: false,
            minZoom: 11
        });
        // Using Leaflet's fitBounds method ensures that the resultant map contains all of the points on all display
        // devices. The precise points were arrived at by the high scientific method of guess-and-check.
        map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]]);
        // More disabling things.
        map.dragging.disable();
        map.keyboard.disable();
        map.doubleClickZoom.disable();
        // I also use a CSS control to change the cursor from a draggy hand to a regular one as well in order to
        // keep users from thinking it is interactive at the beginning.
        // Gib tile layer.
        L.tileLayer('http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> &copy; <a href="http://cartodb.com/attributions">CartoDB</a>',
            subdomains: 'abcd',
            maxZoom: 16
        }).addTo(map);
        // Thx.

        //////////////////////
        // GLOBAL VARIABLES //
        //////////////////////
        // Variables declared inside of the draw callback will be reset every time that the map zoom level is changed.
        // Therefore variables which have to exist outside of the draw state live here.

        // While the intro animation is playing we disable map interactions because d3SvgOverlay doesn't handle
        // having to redraw things that are partially animated. So we store a global for this purpose. Once the
        // intro animation is done we switch this to false and enable interactions. Future draws refer this variable
        // when deciding how to repaint.
        var is_intro_anim = true;

        // The scale factor global is used while redrawing to keep interactive display elements at a reasonable size at
        // all zoom levels. This is necessary because by default d3SvgOverlay will simply keep the objects at the same
        // size at all zoom levels, which causes massive blobs at high zoom levels and tiny specks at low ones.
        var scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.25);

        // In order to implement the station toggle selection we need to implement a global struct which stores
        // stations selected and the paths that have been drawn associated with them.
        // In the first part of the view, before launching any visualization, this data just contains a list of all of
        // the selected station ids. The actual data is populated once the user hits the Go button; to see how things
        // are structured at that point see bindData(), way below.
        var selected_stations = {};

        // The current visualization mode.
        var viz_mode = "intro";

        // D3-SVG-Overlay callback wrapper. Leaflet is used only for the base map, all of the programmatic action occurs
        // in d3 code inside of this callback.
        var mapOverlay = L.d3SvgOverlay(function(sel,proj) {

            //////////////////////
            // INTRO ANIMATION  //
            //////////////////////
            // Design:
            // For the introduction I wanted to dynamically render a random set of paths (200 of them in the final
            // visualization) before painting the rest of the introductory scene.
            //
            // Implementation:
            // runIntroAnimation() -> paintPathSampler() -> paintPath()
            //                     -> paintBackgroundPanel()
            //                     -> paintStations()
            //                     -> drawInfoBox() [function from the "infobox" section, the intro adds a timeout]
            //                     -> enableInteractions()
            //
            // Notes:
            // * Zooming and panning are disabled while the introduction is playing. They are re-enabled once it's over.
            // * The sample paths fade out as soon as the user zooms in or selects a visualization mode.
            // * The `is_intro_anim` global boolean tells the main scene painter (way below) how to behave.

            // Paints a single sampler path. Accepts a linearray (an array of points) as input, as well as the position
            // of the line being drawn in placement order. paintPathSampler is the method which actually handles the
            // entire path-sampling introductory animation, and it implements this method over a loop to do that.
            function paintPath(linearray, index) {

                // Define the SVG line reprojection function.
                var line = d3.svg.line()
                        .x(function (d) {
                            return proj.latLngToLayerPoint(d).x
                        })
                        .y(function (d) {
                            return proj.latLngToLayerPoint(d).y
                        });

                // Create a path, bind the line array to its __data__, and call line on it to generate the line-code.
                setTimeout(function () {
                    sel.append('path').datum(linearray)
                            .attr({
                                "class": "sample-line",
                                "d": line,
                                "fill": "transparent",
                                "stroke": "white",
                                "stroke-width": 3,
                                "vector-effect": "non-scaling-stroke"
                            })
                            .transition()
                            .duration(2500)
                            .attr({
                                "stroke": "#99bbd7"
                            })
                }, 25 * i);
            }

            // Paint all of the sampler paths. Wraps paintPath(), above, with consideration removing old paths.
            // The data file itself, `sample_trips.json`, was generated using Python.
            function paintPathSampler() {
                // Remove all of the existing paths first, otherwise we keep old ones!
                sel.selectAll('path').remove();

                d3.json("../../static/post_assets/citibike/sample_trips.json", function (data) {
                    for (i = 0; i < data.length; i++) {
                        paintPath(data[i], i);
                    }
                });
            }

            // Paints all of the stations on the map.
            function paintStations() {
                d3.csv("../../static/post_assets/citibike/june_22_station_metadata.csv", function (error, dataset) {
                    if (error) throw error;

                    setTimeout(function () {
                        sel
                                .append("g")
                                .attr("id", "display-elements")
                                .append("g")
                                .attr("id", "stations")  // groups are for display---cf. launchVisualizationAnimation()
                                .selectAll("circle")
                                .data(dataset)
                                .enter()
                                .append("circle")
                                .attr({
                                    "class": "station station-unselected",
                                    "cx": function (d) {
                                        return proj.latLngToLayerPoint([d.latitude, d.longitude]).x
                                    },
                                    "cy": function (d) {
                                        return proj.latLngToLayerPoint([d.latitude, d.longitude]).y
                                    },
                                    "r": 0,
                                    "stroke": "white",
                                    "stroke-width": 2,
                                    "cursor": "pointer",
                                    "fill": function (d) {
                                        if (d['kind'] == 'active') {
                                            return "#3f75a2";
                                        }
                                        else if (d['kind'] == 'inactive') {
                                            return "#a7a7a7";
                                        }
                                    },
                                    "fill-opacity": 1,
                                    "stroke-opacity": 1,
                                    "z-index": 10
                                })
                                .on('mouseover', function (d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 4,
                                                "r": 10,
                                                "id": "hovered-station"
                                            });
                                    showCard(d);
                                })
                                .on('mouseout', function (d, i) {
                                    d3.select(this)
                                            .attr({
                                                "stroke-width": 2,
                                                "r": 5,
                                                "id": null
                                            });
                                    hideCard();
                                })
                                .on("click", toggleStation)
                                .transition()
                                .duration(500)
                                .attr({
                                    "r": 5
                                })
                    }, 6000);
                });
            }

            // Enables interactions (meant to be used once the animation is done playing).
            function enableInteractions() {
                is_intro_anim = false;
                d3.select("#map-canvas").style("cursor", null);
                map.dragging.enable();
                map.keyboard.enable();
                map.scrollWheelZoom.enable();
            }

            // Disables interactions. Actually not currently used during the intro, used instead during the later
            // actual visualization.
            function disableInteractions() {
                d3.select("#map-canvas").style("cursor", "default");
                map.dragging.disable();
                map.keyboard.disable();
                map.doubleClickZoom.disable();
                map.scrollWheelZoom.disable();
            }


            // This function runs the intro animation.
            function runIntroAnimation() {
                d3.select("#map-canvas").style("cursor", "default");  // change cursor to the default while animating.
                paintPathSampler();  // Animate the sample paths.
                paintStations();  // Animate the stations.
                setTimeout(function () {
                    paintIntroInfo();  // Append the intro text box. This method is from the Info Box code segment.
                }, 6000);
                setTimeout(function () {
                    enableInteractions();
                }, 6000);
            }

            //////////////
            // INFO BOX //
            //////////////
            // Design:
            // Handles the information display on the left-hand side. A different one is created every time the viz
            // mode is switched.
            //
            // Implementation:
            // {paintIntroInfo(), paintStationsInfo(), paintBikesInfo()} -> drawInfoBox()
            //

            // Draws the info box. This method is used by the information pane painters (there are three, one for each
            // viz mode: intro, stations, bikes). Since the height and width and whatnot of the display depends on the
            // device, all of the sizing for this box are calculated with respect to extrema on the map.
            function drawInfoBox() {
                // Remove any pre-existing ones, we re-draw every time we return.
                d3.select("#description-block").remove();

                // Create the container.
                d3.select("#map-canvas")
                        .append("div")
                        .attr("id", "description-block")
                        .style({
                            "position": "absolute",
                            "width": "400px",
                            // It's easiest to just let height be whatever height the whole thing ends up at.
//                                "height": (proj.latLngToLayerPoint([40.70122128,-74.01234218]).y -
//                                            proj.latLngToLayerPoint([40.784642, -73.970002]).y) + "px",
                            "top": proj.latLngToLayerPoint([40.784642, -73.970002]).y + "px",
                            "left": proj.latLngToLayerPoint([40.704556, -74.026222]).x - 400 - 20 + "px",
                            // ^ (point in the Hudson river) - (width of the box) - (bit of additional padding).
                            "background": "#fff",
                            "border-radius": "5px",
                            "opacity": 0.0,
                            "padding": "10px",
                            "font-family": "Roboto",
                            "text-align": "center",
                            "cursor": "text"
                        })
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1.0
                        });

                // Append title.
                d3.select("#description-block")
                        .append("div")
                        .style({
                            "font-size": "24px",
                            "font-weight": "bold"
                        })
                        .text("A Day in the Life of CitiBike");

            }

            // Paints the introductory info box.
            function paintIntroInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["intro"]);
                });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Stations")
                        .on("click", function () {
                            switchToStationsMode();
                        });

                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn btn-blue"
                        })
                        .style({
                            "width": "50%"
                        })
                        .text("Follow Bikes")
                        .on("click", function () {
                            switchToBikesMode();
                        });

            }

            // Removes everything from the selection. Used by the Reset GUI element. It's factored out because it's
            // common to both functions.
            // This really ought to be in the station selection block, but for some reason when it's there it breaks my
            // build.
            function clearSelection() {
                d3.selectAll(".station-selected").attr({
                    "stroke": "white",
                    "class": "station"
                });
                selected_stations = {};
                updateSelectionDisplay();
                updateResetAndLaunchButtonStyles();
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // bounces you back to the intro. It's factored out because it's common to both functions.
            function appendMenuGoBack(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": "btn"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Go Back")
                        .on("click", function () {
                            switchToIntroMode();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // launches the visualization. It's factored out because it's common to both functions.
            function appendMenuLaunch(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "id": "launch-button",
                            "class": function () {
                                var selection_size = Object.keys(selected_stations).length;
                                if (selection_size == 0) {
                                    return "btn-disabled";
                                }
                                else {
                                    return "btn btn-blue";
                                }
                            }
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Launch")
                        .on("click", function () {
                            d3.select("#launch-button").attr({"class": "btn-disabled"}).on("click", null);
                            initLoadingScreen();
                        });
            }

            // This helper function creates and appends a button that when in station mode or in bike mode and hit
            // removes all of the stations in your current selection. It's factored out because it's common to both
            // functions.
            function appendMenuReset(button_holder) {
                button_holder.append("button")
                        .attr({
                            "type": "button",
                            "class": function () {
                                if (Object.keys(selected_stations).length == 0) {
                                    return "btn-disabled";
                                }
                                else {
                                    return "btn"
                                }
                            },
                            "id": "reset-button"
                        })
                        .style({
                            "width": "33%"
                        })
                        .text("Reset")
                        .on("click", function () {
                            clearSelection();  // in the station selection section.
                            updateSelectionDisplay();  // Necessary in case there are preexisting selections.
                            updateResetAndLaunchButtonStyles();
                        });
            }

            // Paints the stations info box.
            function paintStationsInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["stations"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            // Paints the bikes info box.
            function paintBikesInfo() {
                drawInfoBox();

                var text_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "text-align": "left"
                        });
                var button_holder = d3.select("#description-block")
                        .append("div")
                        .style({
                            "width": "100%",
                            "margin-top": "30px"
                        });

                d3.json("../../static/post_assets/citibike/content_descriptions.json", function (text) {
                    text_holder.html(text["bikes"]);
                });

                appendMenuGoBack(button_holder);
                appendMenuReset(button_holder);
                appendMenuLaunch(button_holder);

            }

            ///////////////////////
            // STATION SELECTION //
            ///////////////////////
            // Design:
            // This code handles when a user clicks on a station, uses the box select, or hits clear selection.
            //

            // Now the function itself. As a UX decision I decided to split *generating* a selection from plotting its
            // data. I did this to allow doing selections on the introduction pane, before the user chooses a
            // visualization mode. For a UX standpoint this is necessary because not having that there would make it
            // awkward for the user to realize that they can click on things later.
            //
            // From a developer standpoint this means that selected_stations can contain just stations without any data
            // bound to them, necessitating that, on triggering a visualization mode, we call a function which checks
            // and binds data to the current selection, if necessary. It also requires a global flag for what mode
            // the visualization is in, intro or stations or bikes. This is `viz_mode` above.
            function toggleStation(d) {
                var sel_station = d3.select(this);
                // Do nothing if the station is inactive.
                if (d['kind'] == 'active') {
                    if (!(d['station id'] in selected_stations)) {
                        // Station is not currently in the selection, so add it.
                        // Notice the semantics: trips are stored as two dict-indexed arrays, one of trips in and one
                        // of trips out.
                        selected_stations[d['station id']] = {'to': null, 'from': null};
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "black", "class": "station station-selected"});
                    }
                    else {
                        // The element is already in the selection, so remove it (this is a toggle after all).
                        delete selected_stations[d['station id']];
                        // Update the display element.
                        // Change the circle mark to match.
                        sel_station.attr({"stroke": "white", "class": "station station-unselected"});
                    }
                    // Update the display elements.
                    updateSelectionDisplay();
                    updateResetAndLaunchButtonStyles();
                }
            }

            // The following helper method updates the selection display.
            // It is called by toggleStation() whenever a station is added to the selection or removed from it.
            function updateSelectionDisplay() {
                var selection_size = Object.keys(selected_stations).length;
                if (selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#selection-display").remove();
                }
                else {
                    // If there's just one selection that means we just selected our first station.
                    // So create the display element.
                    // Note: the display element is drawn on the HTML map canvas level, not the SVG level. This is
                    // because it's rather difficult to get an SVG box into the top right corner, but trivial to
                    // do so in HTML.
                    d3.select("#selection-display").remove();
                    d3.select("#map-canvas").append("div")
                            .attr({
                                "id": "selection-display"
                            })
                            .style({
                                "position": "absolute",
                                "top": "20px",
                                "right": "20px",
                                "width": "400px",
                                "background": "transparent",
//                                    "border": "1px solid black",
                                "text-align": "right"
                            })
                            .html(function (d) {
                                // The string is fairly complicated to write, so let's break it up into parts.
                                // First we put down the part that always displays, the selection size.
                                // Since the presence or lack thereof of that pesky "s" depends on the pluralization we
                                // have to deal with that first.
                                var s = "";
                                if (selection_size > 1) {
                                    s = "s";
                                }
                                // Now the basic display string.
                                var display =
                                        "<div style='font-family:Roboto; line-height:1'>" +
                                        "<div style='font-weight: bold; font-size: 24px; '>" +
                                        selection_size + " Station" + s + " Selected</div>";
                                // Ok, if we are on the introductory screen this is all we need.
                                if (viz_mode == "intro") {
                                    return display;
                                }
                                // If not then we have to do more work. For starters, get all of the selected elements.
                                // (when an element is selected it is added to the station-selected class list. This
                                //  is done explicitly for the purposes of this here function!)
                                var all_selected_stations_data = d3.selectAll(".station-selected").data();
                                // We're going to need a trip counter.
                                var total_trips = 0;
                                // Now we'll need to iterate through these and add something which is dependent on the
                                // mode. If we're in stations mode we need "all trips". If we're in bikes mode we need
                                // "outbound trips" plus "inbound trips".
                                var i = 0;
                                if (viz_mode == "stations") {
                                    for (i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['all trips'];
                                    }
                                }
                                else if (viz_mode == "bikes") {
                                    for (i = 0; i < all_selected_stations_data.length; i++) {
                                        total_trips += +all_selected_stations_data[i]['outbound trips'];
                                        total_trips += +all_selected_stations_data[i]['inbound trips'];
                                    }
                                }
                                // Write this data to the string.
                                display += "<br/>" + total_trips + " trips will be plotted." + "</div>";
                                return display;
                                // Write the string.
//                                return "<div style='font-weight: bold; font-size: 24px; font-family:Roboto;'>" +
//                                        selection_size + " Station" + s + " Selected</div><br/>" +
//                                        trips_to_be_visualized_line
                            });
                }

            }

            // Sets or unsets updateButton clickiness based on whether or not there are stations are in the current
            // selection.
            function updateResetAndLaunchButtonStyles() {
                var selection_size = Object.keys(selected_stations).length;
                if (selection_size == 0) {
                    // If no stations are selected then we just removed our last selection, so remove the display.
                    d3.select("#reset-button").attr({"class": "btn-disabled"}).on("click", null);
                    d3.select("#launch-button").attr({"class": "btn-disabled"}).on("click", null);
                }
                else {
                    d3.select("#reset-button").attr({"class": "btn"}).on("click", function(d) {
                            clearSelection();  // in the station selection section.
                            updateSelectionDisplay();  // Necessary in case there are preexisting selections.
                            updateResetAndLaunchButtonStyles();
                    });
                    d3.select("#launch-button").attr({"class": "btn btn-blue"}).on("click", function(d) {
                            d3.select("#launch-button").attr({"class": "btn-disabled"}).on("click", null);
                            initLoadingScreen();
                    });
                }
            }

            ///////////
            // CARDS //
            ///////////
            // Cards are little infoboxes which appear on a station.

            // Displays the appropriate tooltip for the selected station.
            function showCard(d) {
                var sel_station = d3.select("#hovered-station");
                var card = d3.select("#map-canvas")
                        .append("div")
                        .attr({"class": "station-tip"})
                        .html(function () {
                            var underline = null;
                            if (d['kind'] == 'inactive') {
                                underline = "Out of Service" + "</span></div>";
                            }
                            else {
                                if (viz_mode == 'intro') {
                                    var bikes_out_in = +d['bikes outbound'] + +d['bikes inbound'];
                                    // Pluralize!
                                    var bikes_out_s = "s";
                                    var trips_s = "s";
                                    if (+d['all trips'] == 1) {
                                        trips_s = "";
                                    }
                                    if (bikes_out_in == 1) {
                                        bikes_out_s = "";
                                    }

                                    underline = d['all trips'] +
                                            " trip" + trips_s + " to or from here.<br/>" +
                                            bikes_out_in + " bike" + bikes_out_s + " began or ended the day here." +
                                            "</span></div>";
                                }
                                else if ((viz_mode == 'stations') || (viz_mode == 'stations-animation')) {
                                    underline = d['incoming trips'] +
                                            " trips to this station.<br/>"
                                            + d['outgoing trips']
                                            + " trips from this station.<br/>"
//                                    + d['all trips'] + " trips total."
                                            + "</span></div>";
                                }
                                else if ((viz_mode == 'bikes') || (viz_mode == 'bikes-animation')) {
                                    // Pluralize!
                                    var out_s = "s";
                                    if (+d['bikes outbound'] == 1) {
                                        out_s = "";
                                    }
                                    underline = d['bikes outbound'] +
                                            " bike" + out_s + " started the day here.<br/> " +
                                            d['bikes inbound'] + " ended it here." +
                                            "</span></div>";
                                }
                            }
                            return "<div style='text-align:center'>" +
                                    "<span style='font-weight:bold; font-size:24px;'>" +
                                    d['station name'] +
                                    "</span><br/><span style='font-size:16px;'>" + underline;
                        });
                // the position of the tooltip---top or bottom---depends on what mode we are in.
                if ((viz_mode == "intro") || (viz_mode == "bikes") || (viz_mode == "stations")) {
                    card.style("bottom", "20px");
                } else {
                    card.style("top", "90px");
                }
            }

            // Removes the tooltip.
            function hideCard() {
                d3.select(".station-tip").remove();
            }

            ////////////////////
            // MODAL SWITCHES //
            ////////////////////
            // Design:
            // When you click the modal buttons, this code takes you to that visualization mode. What happens then is
            // TBD.
            //

            // Once you have gotten as far as selecting a visualization type the sampler paths go bye-bye.
            function fadeOutSamplerPaths() {
                var sample_lines = d3.selectAll(".sample-line");
                sample_lines
                        .transition()
                        .duration(2000)
                        .style({"opacity": 0})
                        .remove();
            }

            function switchToBikesMode() {
                viz_mode = "bikes";
                fadeOutSamplerPaths();
                paintBikesInfo();
                applyBikesModeColorMap();
                updateSelectionDisplay();
            }

            function switchToStationsMode() {
                viz_mode = "stations";
                fadeOutSamplerPaths();
                paintStationsInfo();
                applyStationsModeColorMap();
                updateSelectionDisplay();
            }

            function switchToIntroMode() {
                viz_mode = "intro";
                paintIntroInfo();
                applyIntroColorMap();
                updateSelectionDisplay();
            }

            //////////////////
            // COLORIZATION //
            //////////////////
            // Design:
            // These functions define the colormap for each of the different viz types.
            //

            function applyBikesModeColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else if (d['delta bikes'] < 0) {
                                    return "#d8b365";
                                }
                                else if (d['delta bikes'] >= 0) {
                                    return "#3f75a2";
                                }
//                                else {
//                                    return "#3f75a2";
//                                }
                            }
                        });
            }

            function applyStationsModeColorMap() {
//                var stations_color_scale = d3.scale.linear().domain([0, 1500]).range(["#a7c4dd", "#152635"]);
                var all_data = d3.selectAll(".station").data().map(function (d) {
                    return d['all trips']
                });
                var stations_color_scale = d3.scale.quantile().domain(all_data).range(['lightsteelblue',
                    'steelblue', '#2b4f6d']);

                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else {
                                    return stations_color_scale(d['all trips']);
                                }
                            }
                        });
            }

            function applyIntroColorMap() {
                d3.selectAll(".station")
                        .transition()
                        .duration(500)
                        .attr({
                            "fill": function (d) {
                                if (d['kind'] == 'inactive') {
                                    return "#a7a7a7";
                                }
                                else {
                                    return "#3f75a2";
                                }
                            }
                        });
            }

            //////////////////
            // RE-RENDERING //
            //////////////////
            // Design:
            // These methods handle tweaking stations and jittering the hover tooltip when the map is zoomed, so that
            // everything stays in the correct place and has the correct size.

            function rerenderStations() {
                d3.selectAll(".station")
                        .attr({
                            "r": 5 * scale_factor,
                            "stroke-width": 2 * scale_factor
                        })
                        .on('mouseover', function (d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 4 * scale_factor,
                                        "r": 10 * scale_factor,
                                        "id": "hovered-station"
                                    });
                            showCard(d);
                        })
                        .on('mouseout', function (d, i) {
                            d3.select(this)
                                    .attr({
                                        "stroke-width": 2 * scale_factor,
                                        "r": 5 * scale_factor,
                                        "id": null
                                    });
                            hideCard();
                        });
            }

            ////////////////////
            // LOADING SCREEN //
            ////////////////////
            // Design:
            // Data is actually bound the selection at the moment when the Launch button is hit.
            // A loading screen keeps the user busy while they wait.
            // This section implements that loading screen.

            // Nicely fades out the data elements present in the selection which are not present in the animation.
            function unpaintNonAnimatedDisplayElements() {
                d3.select("#description-block").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#selection-display").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // When the visualization is done, replace the data elements back onto the screen.
            function repaintNonAnimatedDisplayElements() {
                return null;
                // TODO: Implement.
            }

            // Emits the non-data elements of the loading screen: the background panel, "Loading..." text, and the cute
            // loading animation.
            function paintLoadingElements() {
                // Fade in the background panel.
                var panel = sel.append("rect")
                        .attr({
                            "fill": "black",
                            "width": "100%",
                            "height": "100%",
                            "fill-opacity": 0.0,
                            "id": "background-panel"
                        })
                        .transition()
                        .duration(1000)
                        .attr({
                            "fill-opacity": 0.5
                        });

                var loader = d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50%",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto"
                        })
                        .attr("id", "loader");

                loader.append("img")
                        .attr({
                            "src": "http://127.0.0.1:5000/static/post_assets/citibike/loading-ring.svg"
                        });

                loader.append("div")
                        .style({
                            "margin": "auto",
                            "font-weight": "bold",
                            "font-size": "30px",
                            "color": "white",
                            "font-family": "Roboto"
                        })
                        .text("Loading...");
            }

            // Kills the loading screen. Called once the API data is properly bound, as a part of exitLoadingScreen.
            function unpaintLoadingScreen() {
                d3.select("#loader").transition().duration(1000).style({"opacity": 0}).remove();
                d3.select("#background-panel").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Makes the actual API calls which bind the data elements needed to run the visualization.
            //
            // We populate two data elements here. The first element that we populate is selected_stations, a data
            // struct containing trip information organized thusly:
            //
            // {
            //      <stationid>:
            //          {
            //           'from': [{'geometry': <trip geometry array>, 'properties': <trip properties dict>}, {...}, ...]
            //           'to': [{...}, ...]
            //          },
            //      <...>: {...},
            //      ...
            // }
            //
            // This element contains the information that is used for drawing things. The visualization happens around
            // "ticks" representing minutes, however, and it would be prohibitively expensive to have to check the
            // entire struct for trips happening on the current tick. Instead, I create a lookup table that looks like
            // this:
            //
            // [{'starttime': <moment>,
            //   'stationid': <stationid>,
            //   'type': <from/to>,
            //   'position': <array index>},
            //   {...}]
            //
            // This is `trips_timetable`, below.
            var trips_timetable = [];
            // We'll need to store the current time.
            // The current time is stored here.
            var current_time = moment.utc(0);  // moment.js object
            // It's also useful for us to track what the next time is.
            var next_time = null;  // moment.js object
            // What the current index of interest is.
            var current_index = 0;
            // The time we end everything on.
            var end_time = null;  // moment.js object
            // The interval id assigned to the setInterval instance which runs our timer.
            var interval_id = null;
            // How long a tick lasts (in ms).
            var tick_time = 250;

            // The "callback" parameter should be filled with the function which will run once the data bind is done---
            // in our case this is unpaintLoadingScreen!
            // TODO: Fix this so it actually works! For multiple stations.
            function bindData(call_this_once_done) {
                // The calls to the API are handled by an asynchronous d3 queue, which waits for selected_stations to
                // finish populating before proceeding before continuing. The code below is what executes that.
                var api_paths = null;
                if (viz_mode == "bikes") {
                    api_paths = ["bike-inbounds", "bike-outbounds"]
                }
                else {
                    api_paths = ["incoming-trips", "outgoing-trips"]
                }
                var q = d3.queue();
                for (let key in selected_stations) {  // let is needed here due to closure stuff I don't quite get
                    if (selected_stations.hasOwnProperty(key)) {
                        console.log(key);
                        q.defer(function (callback) {
                            console.log("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[0] +
                                    "/id/" + key);
                            d3.json("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[0] +
                                    "/id/" + key, function (data) {
                                selected_stations[key]['to'] = data;
                                callback(null, data);
                            });
                        });
                        q.defer(function (callback) {
                            console.log("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[1] +
                                    "/id/" + key);
                            d3.json("http://127.0.0.1:5000/citibike-api/" +
                                    api_paths[1] +
                                    "/id/" + key, function (data) {
                                selected_stations[key]['from'] = data;
                                callback(null, data);
                            });
                        });
                    }
                }
                // We wait for all of the data populate. Once that's done, we proceed with creating the timetable, which
                // runs in a single blocking thread, and then with launching the rest of the visualization.
                // Note: var time, declared below, is a moment.js object storing the current time within the viz.
                q.awaitAll(function (error) {
                    if (error) throw error;
                    // Now we create the timetable.
                    var key = null;
                    console.log(selected_stations);
                    for(key in selected_stations) {  // let is not necessary here because we are in a blocking thread
                        if (selected_stations.hasOwnProperty(key)) {
                            var types = ['from', 'to'];
                            for(var j = 0; j < types.length; j++) {
                                var type = types[j];
                                for(var k = 0; k < selected_stations[key][type].length; k++) {
                                    var trip = selected_stations[key][type][k];
                                    var starttime = moment(trip['properties']['starttime'], '6/22/2016 hh:mm:ss');
//                                                .format('h:mm A');
//                                        var starttime = String(
//                                                moment(trip['properties']['starttime'], '6/22/2016 hh:mm:ss')
//                                                        .format('h:mm A')
//                                        );
                                    trips_timetable.push({
                                        'starttime': starttime,
                                        'stationid': key,
                                        'type': type,
                                        'position': k
                                    });
                                }
                            }
                        }
                    }
                    // Now we need to sort the timetable. This is done using built-in moment object comparison.
                    trips_timetable = trips_timetable.sort(function(a, b) { return a['starttime'] > b['starttime']; });
                    // Set the next_time parameter.
                    next_time = trips_timetable[0]['starttime'];
                    // Start the viz off at the first trip of the day. (deep copy)
                    current_time = next_time.clone();
                    // Where we end the visualization.
                    var end_ref = trips_timetable[trips_timetable.length - 1];
                    var end_trip = selected_stations[end_ref['stationid']][end_ref['type']][end_ref['position']];
                    end_time = moment(end_trip['properties']['stoptime']);
                    console.log(trips_timetable);
                    // Initialize the loop and continue!
                    call_this_once_done();
                });
            }

            // Removes non-selected stations from the map.
            function unpaintUnselectedStations() {
                d3.selectAll(".station-unselected")
                        .transition()
                        .duration(2500)
                        .attr({
                            "fill-opacity": 0,
                            "stroke-opacity": 0
                        }).remove();
                // Disable deselection of selected stations.
                d3.selectAll(".station").on("click", null);
                // Disable hover for the now-hidden stations.
//                d3.selectAll(".station-unselected").style("cursor", null);
//                d3.selectAll(".station-unselected").on('mouseover', null);
            }

            // Transitions the map view back to the default one.
            function resetView() {
                map.fitBounds([[40.6794268,-73.92989109999999], [40.789747, -74.075979]],
                        options={'animate':true});
            }

            // Runners for all these things.

            // Continues the transition by removing the loading screen, dropping non-selected stations, zooming out to
            // a planar view, and fiddling with interactivity. Then hands things off to the visualization runner!
            function exitLoadingScreen() {
                var q = d3.queue();
                function transit(callback) {
                    unpaintLoadingScreen();
                    unpaintUnselectedStations();
                    // Paint the timer ahead of launch.
                    paintTimer();
                    // Wait a little bit to allow painters to finish and the user to realize that this is happening.
                    setTimeout(function() {
                        callback(null);
                    }, 1000);
                }
                q.defer(transit);
                q.await(function(error) {
                    launchVisualizationAnimation();
                });
            }

            // First part of the transition. exitLoadingScreen finishes the job after data has loaded.
            function initLoadingScreen() {
                disableInteractions();
                resetView();
                unpaintNonAnimatedDisplayElements();
                paintLoadingElements();
                bindData(exitLoadingScreen);
            }

            /////////////////////
            // TRIP ANIMATIONS //
            /////////////////////
            // These methods handle the core trip animation elements: timekeeping, the timer, and the actual trip-line
            // plotting.

            // Creates the on-screen timer element.
            function paintTimer() {
                d3.select("#map-canvas")
                        .append("g")
                        .style({
                            "position": "absolute",
                            "left": "50%",
                            "top": "50px",
                            "transform": "translate(-50%,-50%)",
                            "display": "inline-block",
                            "margin": "auto",
                            "opacity": 0,
                            "cursor": "text"
                        })
                        .attr("id", "timer")
//                        .on(".drag", null)
                        .transition()
                        .duration(1000)
                        .style({
                            "opacity": 1
                        });

                d3.select("#timer").append("div")
                        .style({
                            "font-size": "40px",
                            "font-weight": "bold"
                        })
                        .attr("id", "timer-text")
//                        .text("12:00 PM");
                        .text(current_time.format('h:mm A'));
            }

            // Removes the trip animation timer element.
            function unpaintTimer() {
                d3.select("#timer").transition().duration(1000).style({"opacity": 0}).remove();
            }

            // Moves the timer forward one tick (one minute) and changes everything that happens as a result.
            function incrementTimer() {
                current_time = current_time.add(1, 'minutes');
                // If we aren't at the end, do stuff.
                if (current_time.format('h:mm A') != end_time.format('h:mm A')) {
                    d3.select("#timer-text").text(current_time.format('h:mm A'));  // Update display.
                    fireLinePainters();
                }
                // If we are at the end, finish and clean up.
                else {
                    fireLinePainters();
                    exitVisualizationAnimation();
                }
            }

            // Handles the line drawing stuff.
            function fireLinePainters() {
                // We only paint things if next_time indicates that a trip happened this minute.
                if (current_time.format('h:mm A') == next_time.format('h:mm A')) {
                    while(trips_timetable[current_index]['starttime'].format('h:mm A') == next_time.format('h:mm A')) {
                        var curr = trips_timetable[current_index];
                        var tripdata = selected_stations[curr['stationid']][curr['type']][curr['position']];
                        var trip_type = curr['type'];
                        fireLinePainter(tripdata, trip_type);
                        current_index++;
                    }
                    next_time = trips_timetable[current_index]['starttime'];
                }
            }

            // This helper method for `fireLinePainters()`, above, handles actually painting one line.
            // The tripdata parameter is the trip's entry in selected_stations---this contains all of the data about
            // the trip itself. The trip_type parameter is the trip type: to/from.
            //
            // See also: plopLine(), far below.
            function fireLinePainter(tripdata, trip_type) {

                // The coordinates that are to be drawn.
                var linedata = tripdata['geometry']['coordinates'];
                // The duration of the line animation, matching the duration of the ride.
                var duration = moment.duration(
                    moment(tripdata['properties']['stoptime']).diff(moment(tripdata['properties']['starttime']))
                ).asMinutes() * tick_time;
                var c = null;  // the color the trip is initially plotted in.
                var fc = null;  // the color the trip eventually fades to.

                // The colors to use for the animation. We pick a bright draw line which then fades to a lighter color
                // for a period of time after the draw is done, by default. However, this behavior changes if we are in
                // a highlighting mode. In that case, the unhighlighted draw color gets muted, while the highlighted
                // draw color doesn't fade.
                if ((trip_type == 'to') && (!highlight_to) && (!highlight_from)) { c = "steelblue"; fc = "#99bbd7" }
                else if ((trip_type == 'to') && (!highlight_to) && (highlight_from)) { c = "#99bbd7"; fc = "#99bbd7"; }
                else if ((trip_type == 'to') && (highlight_to)) { c = "steelblue"; fc = "steelblue"; }
                else if ((trip_type == 'from') && (!highlight_from) && (!highlight_to)) { c = "#b47846"; fc = "#d7b599" }
                else if ((trip_type == 'from') && (!highlight_from) && (highlight_to)) { c = "#d7b599"; fc = "#d7b599"; }
                else if ((trip_type == 'from') && (highlight_from)) { c = "#b47846"; fc = "#b47846"; }

                // The linearization algorithm...
                var line = d3.svg.line()
//                        .interpolate("cardinal")
                        .x(function(d) { return proj.latLngToLayerPoint(d).x; })
                        .y(function(d) { return proj.latLngToLayerPoint(d).y; });
                // And the class of the trip, for use by the highlighting selector.
                var composite_class = "trip-line trip-line-" + trip_type;

                // display-elements is the id given to the <g> tag which holds (1) all of the station circle elements
                // that are initialized when the introductory animation is finished and (2) all of the paths that we
                // are now appending underneath them.
                //
                // In an SVG things are plotted in "painter" mode: the order of the elements is the order in which they
                // appear in the document body. This is the default behavior when we use "append"; we don't want that.
                // Hence we use this group, selected by id, and the d3 "insert" method (with the :first-child CSS
                // selector) to prepend the path instead.
                //
                // cf. http://stackoverflow.com/questions/26234636/d3-js-prepend-similar-to-jquery-prepend
//                var path = d3.select("#display-elements").insert("path", ":first-child");

                var path = d3.select("#trips").append("path");
                path
                        .attr({
                            "class": composite_class,
                            "d": line(linedata),
                            "stroke-width": "2",
                            "fill": "none",
                            "stroke": c
//                            "vector-effect": "non-scaling-stroke"
                        });
                var totalLength = path.node().getTotalLength();
                // Plot through the trip time.
                path
                        .attr("stroke-dasharray", totalLength + " " + totalLength)
                        .attr("stroke-dashoffset", totalLength)
                        .transition()
                        .duration(duration)
                        .attr("stroke-dashoffset", 0);
                // Bind the trip data to the path, for use later.
                var data_to_bind = tripdata['properties'];
                data_to_bind['type'] = trip_type;
                path.datum(data_to_bind);
                path.data()['type'] = trip_type;
                // Populate the highlighter events.
                if (viz_mode == "stations-animation") {
                    path.on("mouseover", highlightPath);
                    path.on("mouseout", unhighlightPath);
                }
                else if (viz_mode == "bikes-animation") {
                    path.on("mouseover", highlightPaths);
                    path.on("mouseout", unhighlightPaths);
                }
                // Change the cursor to highlight interactivity.
                path.style("cursor", "pointer");
                // Fade color after plotting is done, *if* not in any highlighting mode.
                if ((!highlight_to) && (!highlight_from)) {
                    path
                            .transition()
                            .delay(duration)
                            .duration(30 * tick_time)
                            .attr("stroke", fc);
                }
            }

            function launchVisualizationAnimation() {
                // Set the global viz_mode flag appropriately  (used by e.g. the tooltip display).
                viz_mode = viz_mode + "-animation";
                // Enable interactions again, and set the visualization flag to true.
                enableInteractions();
                // Create a new group for the lines.
                // This group is placed before the stations in the document object model so that the lines appear
                // *below* the stations.
                //
                // display-elements is the id given to the <g> tag which holds (1) all of the station circle elements
                // that are initialized when the introductory animation is finished and (2) all of the paths that we
                // are now appending underneath them. These are sorted, respectively, into the "stations" and "trips"
                // class groups.
                //
                // In an SVG things are plotted in "painter" mode: the order of the elements is the order in which they
                // appear in the document body. This is the default behavior when we use "append"; we don't want that.
                // Hence we use this group, selected by id, and the d3 "insert" method (with the :first-child CSS
                // selector) to prepend the path instead.
                //
                // Afterwards the lines are added to this group by "append", causing them to appear in order and---
                // critically---overplot one another.
                //
                // cf. http://stackoverflow.com/questions/26234636/d3-js-prepend-similar-to-jquery-prepend
                //
                // The plotted trips are placed inside of this element later on.
                d3.select("#display-elements")
                                                .insert("g", ":first-child")
                                                .attr("id", "trips");
                // Paint the legend display element.
                paintLegendDisplay();
                // The first time the incrementer (below) is fired it shifts to one minute after the current time, and
                // *then* checks if it needs to draw anything. This will leave out any trips that occur at exactly the
                // starting minute of the visualization. To include these, we fire the painter event for them manually
                // first.
                fireLinePainters();
                // Set up the timer tick event.
                // That signals its own end, eventually, calling exitVisualizationAnimation() below.
                interval_id = window.setInterval(incrementTimer, tick_time);

            }

            // Cleans up after the visualization is done.
            function exitVisualizationAnimation() {
                window.clearInterval(interval_id);
                // TODO: Implement!
                repaintNonAnimatedDisplayElements();
            }

            ////////////
            // LEGEND //
            ////////////
            // These methods handle the legend display element. The legend (1) tells users what color means what and
            // (2) allows them to toggle dislaying one category of trips, the other category of trips, or both.

            function paintLegendDisplay() {

                // Before we proceed, we generate the text label we're putting in the box.
                var to_text = null;
                var from_text = null;
                var selection_size = Object.keys(selected_stations).length;
                if (viz_mode == "stations-animation" && selection_size > 1) {
                    from_text = "Trips from Selected Stations"; to_text = "Trips to Selected Stations";
                }
                else if (viz_mode == "stations-animation" && selection_size == 1) {
                    from_text = "Trips from Selected Station"; to_text = "Trips to Selected Station"
                }
                else if (viz_mode == "bikes-animation" && selection_size > 1) {
                    from_text = "Bicycles Outbound from Selected Stations";
                    to_text = "Bicycles Inbound to Selected Stations";
                }
                else if (viz_mode == "bikes-animation" && selection_size == 1) {
                    from_text = "Bicycles Outbound from Selected Station";
                    to_text = "Bicycles Inbound to Selected Station";
                }

                // Now paint the element.
                // Note: the display element is drawn on the HTML map canvas level, not the SVG level. This is
                // because it's rather difficult to get an SVG box into the top right corner, but trivial to
                // do so in HTML.
                d3.select("#map-canvas").append("div")
                        .attr({
                            "id": "legend-display"
                        })
                        .style({
                            "position": "absolute",
                            "top": "20px",
                            "right": "20px",
//                            "width": "220px",
                            "background": "white",
                            "border-radius": "5px",
                            "text-align": "right",
                            "cursor": "pointer",
                            "padding": "10px",
                            "opacity": 0
                        })
                        .transition()
                        .duration(1000)
                        .style("opacity", 1);
                d3.select("#legend-display").append("div")
                        .attr("id", "to-legend-display-block")
                        .style("margin-bottom", "30px")
                        .on("mouseover", function() {
                            enableMouseoverHighlightType("to");
                        })
                        .on("mouseout", function() {
                            disableMouseoverHighlightType("to");
                        })
                        .on("click", function() {
                            clickToggleHighlightType("to")
                        });
                d3.select("#legend-display").append("div")
                        .attr("id", "from-legend-display-block")
                        .style("margin-top", "30px")
                        .on("mouseover", function() {
                            enableMouseoverHighlightType("from");
                        })
                        .on("mouseout", function() {
                            disableMouseoverHighlightType("from");
                        })
                        .on("click", function() {
                            clickToggleHighlightType("from")
                        });
                d3.select("#to-legend-display-block")
                        .append("div")
                        .attr("id", "to-legend-circle")
                        .style({
                            "width": "20px",
                            "height": "20px",
                            "border-radius": "10px",
                            "background": "steelblue",
                            "float": "left",
                            "margin-right": "20px"
                        });
                d3.select("#to-legend-display-block")
                        .append("div")
                        .style({
                            "float": "right",
                            "font-family": "Roboto",
                            "font-weight": "bold",
                            "font-size": "14px"
                        })
                        .text(to_text);
                d3.select("#from-legend-display-block")
                        .append("div")
                        .attr("id", "from-legend-circle")
                        .style({
                            "width": "20px",
                            "height": "20px",
                            "border-radius": "10px",
                            "background": "#b47846",
                            "float": "left",
                            "margin-right": "20px"
                        });
                d3.select("#from-legend-display-block")
                        .append("div")
                        .style({
                            "float": "right",
                            "font-family": "Roboto",
                            "font-weight": "bold",
                            "font-size": "14px"
                        })
                        .text(from_text);
            }

            ///////////////////////
            // TYPE HIGHLIGHTERS //
            ///////////////////////
            // These methods handle what happens when you highlight elementy by type using the legend.

            // Global variables for whether or not the viz is in highlighted modes.
            var highlight_to = false;
            var highlight_from = false;

            // Helper monkey-patch function for bringing selections to the front. Wrapped by bringTripLinesToFront().
            // cf. http://bl.ocks.org/eesur/4e0a69d57d3bfc8a82c2
            d3.selection.prototype.moveToFront = function() {
                return this.each(function(){
                    this.parentNode.appendChild(this);
                });
            };

            // Helper function which brings trip-lines of the given type to the front of the view.
            function bringTripLinesToFront(type) {
                d3.selectAll(".trip-line-" + type).moveToFront();
            }

            // Creates a highlight, based on the status of the highlight flags above (does *not* set these flags
            // itself!)
            function highlightType(type) {
                if (type == "to") {
                    d3.selectAll(".trip-line-to").attr("stroke", "steelblue");
                    if (!highlight_from) {
                        d3.selectAll(".trip-line-from").attr("stroke", "#d7b599");
                    }
                }
                if (type == "from") {
                    d3.selectAll(".trip-line-from").attr("stroke", "#b47846");
                    if (!highlight_to) {
                        d3.selectAll(".trip-line-to").attr("stroke", "#99bbd7");
                    }
                }
                bringTripLinesToFront(type);
            }

            // Removes a type highlight.
            function unhighlightType(type) {
                if (type == "to") {
                    d3.selectAll(".trip-line-to").attr("stroke", "#99bbd7");
                }
                if (type == "from") {
                    d3.selectAll(".trip-line-from").attr("stroke", "#d7b599");
                }
            }

            function enableMouseoverHighlightType(type) {
                // first manipulate the display elements.
                var new_color = null;
                if (type == "to") { new_color = "steelblue"; } else { new_color = "#b47846" }
                d3.select("#" + type + "-legend-display-block")
                        .style("color", new_color);
                d3.select("#" + type + "-legend-circle")
                        .style("border", "2px solid black");
                // Actually enable the highlight.
                if (type == "to" && !highlight_to) {
                    highlightType(type);
                } else if (type == "from" && !highlight_from) {
                    highlightType(type);
                }
            }

            function disableMouseoverHighlightType(type) {
                if ((type == "to" && !highlight_to) || (type == "from" && !highlight_from)) {
                    d3.select("#" +type + "-legend-circle")
                            .style("border", null);
                    // Actually disable the highlight.
                    unhighlightType(type);
                }
                d3.select("#" +type + "-legend-display-block").style("color", null);
            }

            function clickToggleHighlightType(type) {
                if (type == "to") {
                    highlight_to = !highlight_to;
                } else {
                    highlight_from = !highlight_from;
                }
                if ((type == "to" && highlight_to) || (type == "from" && highlight_from)) {
                    highlightType(type);
                } else if ((type == "to" && !highlight_to) || (type == "from" && !highlight_from)) {
                    unhighlightType(type);
                }
            }

            ///////////////////////
            // PATH HIGHLIGHTERS //
            ///////////////////////
            // These methods handle highlighting an individual trip or trip-set, and their implementation vis-a-vis
            // path hovering and clicking.

            // Highlights an individual path and also posts that highlighted path's card.
            // This is used directly when in stations-animation viz_mode, and via highlightPaths() when in
            // bikes-animation viz_mode.
            function highlightPath(selected_trip) {
                // Some sneaky input manipulation to get both single and multi -trip selection to work.
                if (!selected_trip) {
                    var selected_path = d3.select(this);
                } else {
                    selected_path = selected_trip;
                }
//                selected_path.transition();  // cancels the fading transition, if one is present.
                selected_path.moveToFront();  // move the current element to the front (monkey-patched).
                if (selected_path.datum()['type'] == "to") {
                    selected_path.attr("stroke", "#1a3043");
                } else {
                    selected_path.attr("stroke", "#432d1a");
                }
            }

            // Undoes the above.
            function unhighlightPath(selected_trip) {
                if (!selected_trip) {
                    var selected_path = d3.select(this);
                } else {
                    selected_path = selected_trip;
                }
                if (selected_path.datum()['type'] == "to") {
                    if(!highlight_to) {
                        selected_path.attr("stroke", "#99bbd7");
                    } else {
                        selected_path.attr("stroke", "steelblue");
                    }
                } else {
                    if(!highlight_from) {
                        selected_path.attr("stroke", "#d7b599");
                    }
                    else {
                        selected_path.attr("stroke", "#b47846");
                    }
                }
            }

            // This wraps highlightPath() for multi-highlight in stations mode.
            function highlightPaths() {
                var selected_path = d3.select(this);
                var sel_bikeid = selected_path.datum()['bikeid'];
                console.log(sel_bikeid);
                var selected_trips = d3.selectAll(".trip-line").filter(function(d) {
                    return d['bikeid'] == sel_bikeid;
                });
                console.log(selected_trips);
                selected_trips.each(function(selected_path) {
                    var selected_trip = d3.select(this);
                    console.log(selected_trip);  // if checking the log all 20 of these are present, then each is OK
                    highlightPath(selected_trip);
                });
            }

            // Reverses the above.
            function unhighlightPaths() {
                var selected_path = d3.select(this);
                var sel_bikeid = selected_path.datum()['bikeid'];
                console.log(sel_bikeid);
                var selected_trips = d3.selectAll(".trip-line").filter(function(d) {
                    return d['bikeid'] == sel_bikeid;
                });
                console.log(selected_trips);
                selected_trips.each(function(selected_path) {
                    var selected_trip = d3.select(this);
                    unhighlightPath(selected_trip);
                });
            }
            ////////////////////
            // LINE PLOPPING //
            ///////////////////
            // Both the animation zoomer and the rugplot use line plopping functions from this section. These just plop
            // a line on the page without bothering to animate it.

            // Copy of code from fireLinePainter().
            function plopLine(tripdata, trip_type) {
                // TODO: Implement!
            }

            // Removes a single line, given its data. Used by the rugplot selector!
            function removeLine(tripdata) {
                // TODO: Implement!
            }

            /////////////
            // RUGPLOT //
            /////////////
            // TODO: Implement!

            /////////////////
            // MAIN METHOD //
            /////////////////
            // Everything else above is scoped within functions; those functions are called by the following external
            // main method, in the order needed to get things working.
            //
            // This routine is called when the page is first loaded. But, critically, it is *also* called whenver the
            // page needs to be rerendered---which means, when using Leaflet, whenever the page is zoomed. This is done
            // by D3SvgLeaflet.
            //
            // Thus is we want something to work with zoom, we have to implement what would happen when the map is
            // zoomed *here*.
            //
            // To do that we use a few global variables as flags and specific methods written for the purpose for
            // implementation.
            if(is_intro_anim) {
                runIntroAnimation();
            }
            // Or correct the existing elements to match the display. This is necessary because by default, whenever
            // the map is zoomed D3SvgOverlay keeps the elements on the map at the same scale as the original ones, but
            // of course that's not what we want.
            //
            // So we have to implement station scaling ourselves, manually.
            else {
                // Rescale (scale_factor is a global).
                scale_factor = Math.max(1 / Math.pow(2, map.getZoom() - 13), 0.0625);
                // Correct the displays.
                rerenderStations();
                // Fade out the intro paths, if we haven't already.
                fadeOutSamplerPaths();
            }
        });

        /////////////
        // RUNTIME //
        /////////////
        // That was a d3SvgOverlay callback, the execution of which is handled by this one-liner.
        mapOverlay.addTo(map);
    </script>
</body>
</html>